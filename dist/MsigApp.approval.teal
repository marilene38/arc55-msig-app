#pragma version 10

// This TEAL was generated by TEALScript v0.73.3
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_UpdateApplication call_DeleteApplication create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// onlySigner()void
//
// Check the transaction sender is a signer for the multisig
onlySigner:
	proto 0 0

	// src/arcs/arc55.algo.ts:81
	// assert(this._addressCount(this.txn.sender).exists)
	txna Applications 0
	txn Sender
	app_global_get_ex
	swap
	pop
	assert
	retsub

// onlyCreator()void
//
// Check the transaction sender is the contract creator
onlyCreator:
	proto 0 0

	// src/arcs/arc55.algo.ts:88
	// assert(this.txn.sender === globals.creatorAddress)
	txn Sender
	global CreatorAddress
	==
	assert
	retsub

abi_route_arc55_threshold:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc55_threshold()uint64
	callsub arc55_threshold
	itob
	concat
	log
	int 1
	return

// arc55_threshold()uint64
//
// Retrieve the signature threshold required for the multisignature to be submitted
// @returns Multisignature threshold
arc55_threshold:
	proto 0 1

	// src/arcs/arc55.algo.ts:99
	// return this._threshold.value;
	byte 0x5f7468726573686f6c64 // "_threshold"
	app_global_get
	retsub

abi_route_arc55_transactions:
	// The ABI return prefix
	byte 0x151f7c75

	// transactionIndex: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_transactions(uint8,uint64)byte[]
	callsub arc55_transactions
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// arc55_transactions(uint8,uint64)byte[]
//
// Retrieve a transaction from a given transaction group
// @param transactionGroup Transaction Group nonce
// @param transactionIndex Index of transaction within group
// @returns A single transaction at the specified index for the transaction group nonce
arc55_transactions:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/arcs/arc55.algo.ts:110
	// transactionBox: TransactionGroup = {
	//             nonce: transactionGroup,
	//             index: transactionIndex
	//         }
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // transactionIndex: uint8
	itob
	extract 7 1
	concat
	frame_bury 0 // transactionBox: TransactionGroup

	// src/arcs/arc55.algo.ts:115
	// return this._transactions(transactionBox).value;
	frame_dig 0 // transactionBox: TransactionGroup
	box_get
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_arc55_signatures:
	// The ABI return prefix
	byte 0x151f7c75

	// signer: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_signatures(address,uint64)byte[64][]
	callsub arc55_signatures
	dup
	len
	int 64
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// arc55_signatures(address,uint64)byte[64][]
//
// Retrieve a list of signatures for a given transaction group nonce and address
// @param transactionGroup Transaction Group nonce
// @param signer Address you want to retrieve signatures for
// @returns Array of signatures
arc55_signatures:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/arcs/arc55.algo.ts:126
	// signatureBox: TransactionSignatures = {
	//             nonce: transactionGroup,
	//             address: signer
	//         }
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // signer: Address
	concat
	frame_bury 0 // signatureBox: TransactionSignatures

	// src/arcs/arc55.algo.ts:131
	// return this._signatures(signatureBox).value;
	frame_dig 0 // signatureBox: TransactionSignatures
	box_get
	assert
	extract 2 0

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_arc55_signerByIndex:
	// The ABI return prefix
	byte 0x151f7c75

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_signerByIndex(uint64)address
	callsub arc55_signerByIndex
	concat
	log
	int 1
	return

// arc55_signerByIndex(uint64)address
//
// Find out which address is at this index of the multisignature
// @param index Address at this index of the multisignature
// @returns Address at index
arc55_signerByIndex:
	proto 1 1

	// src/arcs/arc55.algo.ts:141
	// return this._indexToAddress(index).value;
	frame_dig -1 // index: uint64
	itob
	app_global_get
	retsub

abi_route_arc55_isSigner:
	// The ABI return prefix
	byte 0x151f7c75

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc55_isSigner(address)bool
	callsub arc55_isSigner
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc55_isSigner(address)bool
//
// Check if an address is a member of the multisignature
// @param address Address to check is a signer
// @returns True if address is a signer
arc55_isSigner:
	proto 1 1

	// src/arcs/arc55.algo.ts:151
	// return this._addressCount(address).value !== 0;
	frame_dig -1 // address: Address
	app_global_get
	int 0
	!=
	retsub

abi_route_arc55_setup:
	// addresses: address[]
	txna ApplicationArgs 2
	extract 2 0

	// threshold: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute arc55_setup(address[],uint8)void
	callsub arc55_setup
	int 1
	return

// arc55_setup(address[],uint8)void
//
// Setup On-Chain Msig App. This can only be called whilst no transaction groups have been created.
// @param threshold Initial multisig threshold, must be greater than 0
// @param addresses Array of addresses that make up the multisig
arc55_setup:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// src/arcs/arc55.algo.ts:165
	// assert(!this._nonce.value)
	byte 0x5f6e6f6e6365 // "_nonce"
	app_global_get
	!
	assert

	// src/arcs/arc55.algo.ts:166
	// this.onlyCreator()
	callsub onlyCreator

	// src/arcs/arc55.algo.ts:168
	// t: uint<64> = btoi(rawBytes(threshold))
	frame_dig -1 // threshold: uint<8>
	itob
	extract 7 1
	btoi
	frame_bury 0 // t: uint<64>

	// src/arcs/arc55.algo.ts:169
	// assert(t)
	frame_dig 0 // t: uint<64>
	assert

	// src/arcs/arc55.algo.ts:170
	// this._threshold.value = t
	byte 0x5f7468726573686f6c64 // "_threshold"
	frame_dig 0 // t: uint<64>
	app_global_put

	// src/arcs/arc55.algo.ts:172
	// this._nonce.value = 0
	byte 0x5f6e6f6e6365 // "_nonce"
	int 0
	app_global_put

	// src/arcs/arc55.algo.ts:174
	// index = 0
	int 0
	frame_bury 1 // index: uint64

while_0:
	// src/arcs/arc55.algo.ts:176
	// index < addresses.length
	frame_dig 1 // index: uint64
	frame_dig -2 // addresses: Address[]
	len
	int 32
	/
	<
	bz while_0_end

	// src/arcs/arc55.algo.ts:177
	// address = addresses[index]
	frame_dig -2 // addresses: Address[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // index: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	frame_bury 2 // address: Address

	// src/arcs/arc55.algo.ts:180
	// this._indexToAddress(index).value = address
	frame_dig 1 // index: uint64
	itob
	frame_dig 2 // address: Address
	app_global_put

	// src/arcs/arc55.algo.ts:184
	// this._addressCount(address).value = this._addressCount(address).value + 1
	frame_dig 2 // address: Address
	frame_dig 2 // address: Address
	app_global_get
	int 1
	+
	app_global_put

	// src/arcs/arc55.algo.ts:186
	// index = index + 1
	frame_dig 1 // index: uint64
	int 1
	+
	frame_bury 1 // index: uint64
	b while_0

while_0_end:
	retsub

abi_route_arc55_newTransactionGroup:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc55_newTransactionGroup()uint64
	callsub arc55_newTransactionGroup
	itob
	concat
	log
	int 1
	return

// arc55_newTransactionGroup()uint64
//
// Generate a new transaction group nonce for holding pending transactions
// @returns transactionGroup Transaction Group nonce
arc55_newTransactionGroup:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/arcs/arc55.algo.ts:195
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:197
	// n = this._nonce.value + 1
	byte 0x5f6e6f6e6365 // "_nonce"
	app_global_get
	int 1
	+
	frame_bury 0 // n: uint64

	// src/arcs/arc55.algo.ts:198
	// this._nonce.value = n
	byte 0x5f6e6f6e6365 // "_nonce"
	frame_dig 0 // n: uint64
	app_global_put

	// src/arcs/arc55.algo.ts:200
	// return n;
	frame_dig 0 // n: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

abi_route_arc55_addTransaction:
	// transaction: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// index: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// costs: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute arc55_addTransaction(byte[],uint8,uint64,pay)void
	callsub arc55_addTransaction
	int 1
	return

// arc55_addTransaction(byte[],uint8,uint64,pay)void
//
// Add a transaction to an existing group. Only one transaction should be included per call
// @param costs Minimum Balance Requirement for associated box storage costs: (2500) + (400 * (9 + transaction.length))
// @param transactionGroup Transaction Group nonce
// @param index Transaction position within atomic group to add
// @param transaction Transaction to add
arc55_addTransaction:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/arcs/arc55.algo.ts:216
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:221
	// mbrTxnIncrease = (2500) + (400 * (9 + transaction.length))
	int 2500
	int 400
	int 9
	frame_dig -4 // transaction: bytes
	len
	+
	*
	+
	frame_bury 0 // mbrTxnIncrease: uint64

	// src/arcs/arc55.algo.ts:223
	// verifyTxn(costs, {
	//             receiver: this.app.address,
	//             amount: mbrTxnIncrease
	//         })
	// verify receiver
	frame_dig -1 // costs: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // costs: PayTxn
	gtxns Amount
	frame_dig 0 // mbrTxnIncrease: uint64
	==
	assert

	// src/arcs/arc55.algo.ts:228
	// assert(transactionGroup)
	frame_dig -2 // transactionGroup: uint<64>
	assert

	// src/arcs/arc55.algo.ts:229
	// assert(transactionGroup <= this._nonce.value)
	frame_dig -2 // transactionGroup: uint<64>
	byte 0x5f6e6f6e6365 // "_nonce"
	app_global_get
	<=
	assert

	// src/arcs/arc55.algo.ts:231
	// transactionBox: TransactionGroup = {
	//             nonce: transactionGroup,
	//             index: index,
	//         }
	frame_dig -2 // transactionGroup: uint<64>
	itob
	frame_dig -3 // index: uint<8>
	itob
	extract 7 1
	concat
	frame_bury 1 // transactionBox: TransactionGroup

	// src/arcs/arc55.algo.ts:238
	// this._transactions(transactionBox).value = transaction
	frame_dig 1 // transactionBox: TransactionGroup
	dup
	box_del
	pop
	frame_dig -4 // transaction: bytes
	box_put

	// src/arcs/arc55.algo.ts:241
	// this.TransactionAdded.log({
	//             transactionGroup: transactionGroup,
	//             transactionIndex: index
	//         })
	byte 0x1849a594 // TransactionAdded(uint64,uint8)
	frame_dig -2 // transactionGroup: uint<64>
	itob
	frame_dig -3 // index: uint<8>
	itob
	extract 7 1
	concat
	concat
	log
	retsub

abi_route_arc55_removeTransaction:
	// index: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_removeTransaction(uint8,uint64)void
	callsub arc55_removeTransaction
	int 1
	return

// arc55_removeTransaction(uint8,uint64)void
//
// Remove transaction from the app. The MBR associated with the transaction will be returned to the Msig address.
// @param transactionGroup Transaction Group nonce
// @param index Transaction position within atomic group to remove
arc55_removeTransaction:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/arcs/arc55.algo.ts:256
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:258
	// transactionBox: TransactionGroup = {
	//             nonce: transactionGroup,
	//             index: index,
	//         }
	frame_dig -1 // transactionGroup: uint<64>
	itob
	frame_dig -2 // index: uint<8>
	itob
	extract 7 1
	concat
	frame_bury 0 // transactionBox: TransactionGroup

	// src/arcs/arc55.algo.ts:265
	// this._transactions(transactionBox).delete
	frame_dig 0 // transactionBox: TransactionGroup
	box_del

	// src/arcs/arc55.algo.ts:268
	// this.TransactionRemoved.log({
	//             transactionGroup: transactionGroup,
	//             transactionIndex: index
	//         })
	byte 0x3e9b2ca5 // TransactionRemoved(uint64,uint8)
	frame_dig -1 // transactionGroup: uint<64>
	itob
	frame_dig -2 // index: uint<8>
	itob
	extract 7 1
	concat
	concat
	log
	retsub

abi_route_arc55_setSignatures:
	// signatures: byte[64][]
	txna ApplicationArgs 2
	extract 2 0

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// costs: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute arc55_setSignatures(byte[64][],uint64,pay)void
	callsub arc55_setSignatures
	int 1
	return

// arc55_setSignatures(byte[64][],uint64,pay)void
//
// Set signatures for a particular transaction group. Signatures must be included as an array of byte-arrays
// @param costs Minimum Balance Requirement for associated box storage costs: (2500) + (400 * (40 + signatures.length))
// @param transactionGroup Transaction Group nonce
// @param signatures Array of signatures
arc55_setSignatures:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/arcs/arc55.algo.ts:285
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:290
	// mbrSigIncrease = (2500) + (400 * (40 + signatures.length))
	int 2500
	int 400
	int 40
	frame_dig -3 // signatures: bytes64[]
	len
	int 64
	/
	+
	*
	+
	frame_bury 0 // mbrSigIncrease: uint64

	// src/arcs/arc55.algo.ts:292
	// verifyTxn(costs, {
	//             receiver: this.app.address,
	//             amount: mbrSigIncrease,
	//         })
	// verify receiver
	frame_dig -1 // costs: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // costs: PayTxn
	gtxns Amount
	frame_dig 0 // mbrSigIncrease: uint64
	==
	assert

	// src/arcs/arc55.algo.ts:297
	// signatureBox: TransactionSignatures = {
	//             nonce: transactionGroup,
	//             address: this.txn.sender
	//         }
	frame_dig -2 // transactionGroup: uint<64>
	itob
	txn Sender
	concat
	frame_bury 1 // signatureBox: TransactionSignatures

	// src/arcs/arc55.algo.ts:302
	// this._signatures(signatureBox).value = signatures
	frame_dig 1 // signatureBox: TransactionSignatures
	dup
	box_del
	pop
	frame_dig -3 // signatures: bytes64[]
	dup
	len
	int 64
	/
	itob
	extract 6 2
	swap
	concat
	box_put

	// src/arcs/arc55.algo.ts:305
	// this.SignatureSet.log({
	//             transactionGroup: transactionGroup,
	//             signer: this.txn.sender
	//         })
	byte 0xecfbcb33 // SignatureSet(uint64,address)
	frame_dig -2 // transactionGroup: uint<64>
	itob
	txn Sender
	concat
	concat
	log
	retsub

abi_route_arc55_clearSignatures:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_clearSignatures(address,uint64)void
	callsub arc55_clearSignatures
	int 1
	return

// arc55_clearSignatures(address,uint64)void
//
// Clear signatures for an address. Be aware this only removes it from the current state of the ledger, and indexers will still know and could use your signature
// @param transactionGroup Transaction Group nonce
// @param address Address whose signatures to clear
arc55_clearSignatures:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// src/arcs/arc55.algo.ts:320
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:322
	// signatureBox: TransactionSignatures = {
	//             nonce: transactionGroup,
	//             address: address
	//         }
	frame_dig -1 // transactionGroup: uint<64>
	itob
	frame_dig -2 // address: Address
	concat
	frame_bury 0 // signatureBox: TransactionSignatures

	// src/arcs/arc55.algo.ts:327
	// sigLength = this._signatures(signatureBox).size
	frame_dig 0 // signatureBox: TransactionSignatures
	box_len
	assert
	frame_bury 1 // sigLength: uint64

	// src/arcs/arc55.algo.ts:328
	// this._signatures(signatureBox).delete
	frame_dig 0 // signatureBox: TransactionSignatures
	box_del

	// src/arcs/arc55.algo.ts:333
	// mbrSigDecrease = (2500) + (400 * (40 + sigLength))
	int 2500
	int 400
	int 40
	frame_dig 1 // sigLength: uint64
	+
	*
	+
	frame_bury 2 // mbrSigDecrease: uint64

	// src/arcs/arc55.algo.ts:335
	// sendPayment({
	//             receiver: address,
	//             amount: mbrSigDecrease
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/arcs/arc55.algo.ts:336
	// receiver: address
	frame_dig -2 // address: Address
	itxn_field Receiver

	// src/arcs/arc55.algo.ts:337
	// amount: mbrSigDecrease
	frame_dig 2 // mbrSigDecrease: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/arcs/arc55.algo.ts:341
	// this.SignatureSet.log({
	//             transactionGroup: transactionGroup,
	//             signer: address
	//         })
	byte 0xecfbcb33 // SignatureSet(uint64,address)
	frame_dig -1 // transactionGroup: uint<64>
	itob
	frame_dig -2 // address: Address
	concat
	concat
	log
	retsub

abi_route_deploy:
	// The ABI return prefix
	byte 0x151f7c75

	// execute deploy()uint64
	callsub deploy
	itob
	concat
	log
	int 1
	return

// deploy()uint64
//
// Deploy a new On-Chain Msig App.
// @returns Msig App Application ID
deploy:
	proto 0 1

	// src/msig-app.algo.ts:11
	// return globals.currentApplicationID;
	global CurrentApplicationID
	retsub

abi_route_update:
	// execute update()void
	callsub update
	int 1
	return

// update()void
//
// Update the application
update:
	proto 0 0

	// src/msig-app.algo.ts:19
	// this.onlyCreator()
	callsub onlyCreator
	retsub

abi_route_destroy:
	// execute destroy()void
	callsub destroy
	int 1
	return

// destroy()void
//
// Destroy the application and return funds to creator address. All transactions must be removed before calling destroy
destroy:
	proto 0 0

	// src/msig-app.algo.ts:27
	// this.onlyCreator()
	callsub onlyCreator

	// src/msig-app.algo.ts:29
	// sendPayment({
	//             amount: 0,
	//             receiver: globals.creatorAddress,
	//             closeRemainderTo: globals.creatorAddress,
	//             fee: 0,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/msig-app.algo.ts:30
	// amount: 0
	int 0
	itxn_field Amount

	// src/msig-app.algo.ts:31
	// receiver: globals.creatorAddress
	global CreatorAddress
	itxn_field Receiver

	// src/msig-app.algo.ts:32
	// closeRemainderTo: globals.creatorAddress
	global CreatorAddress
	itxn_field CloseRemainderTo

	// src/msig-app.algo.ts:33
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

create_NoOp:
	method "deploy()uint64"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "arc55_threshold()uint64"
	method "arc55_transactions(uint64,uint8)byte[]"
	method "arc55_signatures(uint64,address)byte[64][]"
	method "arc55_signerByIndex(uint64)address"
	method "arc55_isSigner(address)bool"
	method "arc55_setup(uint8,address[])void"
	method "arc55_newTransactionGroup()uint64"
	method "arc55_addTransaction(pay,uint64,uint8,byte[])void"
	method "arc55_removeTransaction(uint64,uint8)void"
	method "arc55_setSignatures(pay,uint64,byte[64][])void"
	method "arc55_clearSignatures(uint64,address)void"
	txna ApplicationArgs 0
	match abi_route_arc55_threshold abi_route_arc55_transactions abi_route_arc55_signatures abi_route_arc55_signerByIndex abi_route_arc55_isSigner abi_route_arc55_setup abi_route_arc55_newTransactionGroup abi_route_arc55_addTransaction abi_route_arc55_removeTransaction abi_route_arc55_setSignatures abi_route_arc55_clearSignatures
	err

call_UpdateApplication:
	method "update()void"
	txna ApplicationArgs 0
	match abi_route_update
	err

call_DeleteApplication:
	method "destroy()void"
	txna ApplicationArgs 0
	match abi_route_destroy
	err