#pragma version 10

// This TEAL was generated by TEALScript v0.76.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_UpdateApplication call_DeleteApplication create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED

NOT_IMPLEMENTED:
	err

// onlySigner(): void
//
// Check the transaction sender is a signer for the multisig
onlySigner:
	proto 0 0

	// src/arcs/arc55.algo.ts:81
	// assert(this._addressCount(this.txn.sender).exists)
	txna Applications 0
	txn Sender
	app_global_get_ex
	swap
	pop
	assert
	retsub

// onlyCreator(): void
//
// Check the transaction sender is the contract creator
onlyCreator:
	proto 0 0

	// src/arcs/arc55.algo.ts:88
	// assert(this.txn.sender === globals.creatorAddress)
	txn Sender
	global CreatorAddress
	==
	assert
	retsub

// arc55_threshold()uint64
abi_route_arc55_threshold:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc55_threshold()uint64
	callsub arc55_threshold
	itob
	concat
	log
	int 1
	return

// arc55_threshold(): uint64
//
// Retrieve the signature threshold required for the multisignature to be submitted
// @returns Multisignature threshold
arc55_threshold:
	proto 0 1

	// src/arcs/arc55.algo.ts:99
	// return this._threshold.value;
	byte 0x5f7468726573686f6c64 // "_threshold"
	app_global_get
	retsub

// arc55_transaction(uint64,uint8)byte[]
abi_route_arc55_transaction:
	// The ABI return prefix
	byte 0x151f7c75

	// transactionIndex: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_transaction(uint64,uint8)byte[]
	callsub arc55_transaction
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// arc55_transaction(transactionGroup: uint64, transactionIndex: uint8): bytes
//
// Retrieve a transaction from a given transaction group
// @param transactionGroup Transaction Group nonce
// @param transactionIndex Index of transaction within group
// @returns A single transaction at the specified index for the transaction group nonce
arc55_transaction:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/arcs/arc55.algo.ts:110
	// transactionBox: TransactionGroup = {
	//             nonce: transactionGroup,
	//             index: transactionIndex
	//         }
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // transactionIndex: uint8
	itob
	extract 7 1
	concat
	frame_bury 0 // transactionBox: TransactionGroup

	// src/arcs/arc55.algo.ts:115
	// return this._transactions(transactionBox).value;
	frame_dig 0 // transactionBox: TransactionGroup
	box_get
	assert

	// set the subroutine return value
	frame_bury 0
	retsub

// arc55_signatures(uint64,address)byte[64][]
abi_route_arc55_signatures:
	// The ABI return prefix
	byte 0x151f7c75

	// signer: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_signatures(uint64,address)byte[64][]
	callsub arc55_signatures
	dup
	len
	int 64
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// arc55_signatures(transactionGroup: uint64, signer: Address): bytes64[]
//
// Retrieve a list of signatures for a given transaction group nonce and address
// @param transactionGroup Transaction Group nonce
// @param signer Address you want to retrieve signatures for
// @returns Array of signatures
arc55_signatures:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/arcs/arc55.algo.ts:126
	// signatureBox: TransactionSignatures = {
	//             nonce: transactionGroup,
	//             address: signer
	//         }
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // signer: Address
	concat
	frame_bury 0 // signatureBox: TransactionSignatures

	// src/arcs/arc55.algo.ts:131
	// return this._signatures(signatureBox).value;
	frame_dig 0 // signatureBox: TransactionSignatures
	int 2
	int 0
	box_extract

	// set the subroutine return value
	frame_bury 0
	retsub

// arc55_signerByIndex(uint64)address
abi_route_arc55_signerByIndex:
	// The ABI return prefix
	byte 0x151f7c75

	// index: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_signerByIndex(uint64)address
	callsub arc55_signerByIndex
	concat
	log
	int 1
	return

// arc55_signerByIndex(index: uint64): Address
//
// Find out which address is at this index of the multisignature
// @param index Address at this index of the multisignature
// @returns Address at index
arc55_signerByIndex:
	proto 1 1

	// src/arcs/arc55.algo.ts:141
	// return this._indexToAddress(index).value;
	frame_dig -1 // index: uint64
	itob
	app_global_get
	retsub

// arc55_isSigner(address)bool
abi_route_arc55_isSigner:
	// The ABI return prefix
	byte 0x151f7c75

	// address: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc55_isSigner(address)bool
	callsub arc55_isSigner
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// arc55_isSigner(address: Address): boolean
//
// Check if an address is a member of the multisignature
// @param address Address to check is a signer
// @returns True if address is a signer
arc55_isSigner:
	proto 1 1

	// src/arcs/arc55.algo.ts:151
	// return this._addressCount(address).value !== 0;
	frame_dig -1 // address: Address
	app_global_get
	int 0
	!=
	retsub

// arc55_mbrSigIncrease(uint64)uint64
abi_route_arc55_mbrSigIncrease:
	// The ABI return prefix
	byte 0x151f7c75

	// signaturesSize: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_mbrSigIncrease(uint64)uint64
	callsub arc55_mbrSigIncrease
	itob
	concat
	log
	int 1
	return

// arc55_mbrSigIncrease(signaturesSize: uint64): uint64
//
// Calculate the minimum balance requirement for storing a signature
// @param signaturesSize Size (in bytes) of the signatures to store
// @returns Minimum balance requirement increase
arc55_mbrSigIncrease:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// src/arcs/arc55.algo.ts:161
	// currentBalance = this.app.address.balance
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	frame_bury 0 // currentBalance: uint64

	// src/arcs/arc55.algo.ts:162
	// minimumBalance = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 1 // minimumBalance: uint64

	// src/arcs/arc55.algo.ts:167
	// mbrSigRequired = (2500) + (400 * (40 + 2 + (64 * signaturesSize)))
	int 2500
	int 400
	int 42
	int 64
	frame_dig -1 // signaturesSize: uint64
	*
	+
	*
	+
	frame_bury 2 // mbrSigRequired: uint64

	// src/arcs/arc55.algo.ts:169
	// newMinimumBalance = minimumBalance + mbrSigRequired
	frame_dig 1 // minimumBalance: uint64
	frame_dig 2 // mbrSigRequired: uint64
	+
	frame_bury 3 // newMinimumBalance: uint64

	// if0_condition
	// src/arcs/arc55.algo.ts:170
	// currentBalance > newMinimumBalance
	frame_dig 0 // currentBalance: uint64
	frame_dig 3 // newMinimumBalance: uint64
	>
	bz if0_end

	// if0_consequent
	// src/arcs/arc55.algo.ts:171
	// return 0;
	int 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

if0_end:
	// src/arcs/arc55.algo.ts:174
	// return newMinimumBalance - currentBalance;
	frame_dig 3 // newMinimumBalance: uint64
	frame_dig 0 // currentBalance: uint64
	-

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// arc55_mbrTxnIncrease(uint64)uint64
abi_route_arc55_mbrTxnIncrease:
	// The ABI return prefix
	byte 0x151f7c75

	// transactionSize: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_mbrTxnIncrease(uint64)uint64
	callsub arc55_mbrTxnIncrease
	itob
	concat
	log
	int 1
	return

// arc55_mbrTxnIncrease(transactionSize: uint64): uint64
//
// Calculate the minimum balance requirement for storing a transaction
// @param transactionSize Size (in bytes) of the transaction to store
// @returns Minimum balance requirement increase
arc55_mbrTxnIncrease:
	proto 1 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// src/arcs/arc55.algo.ts:184
	// currentBalance = this.app.address.balance
	global CurrentApplicationAddress
	acct_params_get AcctBalance
	pop
	frame_bury 0 // currentBalance: uint64

	// src/arcs/arc55.algo.ts:185
	// minimumBalance = this.app.address.minBalance
	global CurrentApplicationAddress
	acct_params_get AcctMinBalance
	pop
	frame_bury 1 // minimumBalance: uint64

	// src/arcs/arc55.algo.ts:190
	// mbrTxnRequired = (2500) + (400 * (9 + transactionSize))
	int 2500
	int 400
	int 9
	frame_dig -1 // transactionSize: uint64
	+
	*
	+
	frame_bury 2 // mbrTxnRequired: uint64

	// src/arcs/arc55.algo.ts:192
	// newMinimumBalance = minimumBalance + mbrTxnRequired
	frame_dig 1 // minimumBalance: uint64
	frame_dig 2 // mbrTxnRequired: uint64
	+
	frame_bury 3 // newMinimumBalance: uint64

	// if1_condition
	// src/arcs/arc55.algo.ts:193
	// currentBalance > newMinimumBalance
	frame_dig 0 // currentBalance: uint64
	frame_dig 3 // newMinimumBalance: uint64
	>
	bz if1_end

	// if1_consequent
	// src/arcs/arc55.algo.ts:194
	// return 0;
	int 0

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

if1_end:
	// src/arcs/arc55.algo.ts:197
	// return newMinimumBalance - currentBalance;
	frame_dig 3 // newMinimumBalance: uint64
	frame_dig 0 // currentBalance: uint64
	-

	// set the subroutine return value
	frame_bury 0

	// pop all local variables from the stack
	popn 3
	retsub

// arc55_setup(uint8,address[])void
abi_route_arc55_setup:
	// addresses: address[]
	txna ApplicationArgs 2
	extract 2 0

	// threshold: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert
	btoi

	// execute arc55_setup(uint8,address[])void
	callsub arc55_setup
	int 1
	return

// arc55_setup(threshold: uint8, addresses: Address[]): void
//
// Setup On-Chain Msig App. This can only be called whilst no transaction groups have been created.
// @param threshold Initial multisig threshold, must be greater than 0
// @param addresses Array of addresses that make up the multisig
arc55_setup:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 5

	// src/arcs/arc55.algo.ts:211
	// assert(!this._nonce.value)
	byte 0x5f6e6f6e6365 // "_nonce"
	app_global_get
	!
	assert

	// src/arcs/arc55.algo.ts:212
	// this.onlyCreator()
	callsub onlyCreator

	// src/arcs/arc55.algo.ts:214
	// t: uint64 = btoi(rawBytes(threshold))
	frame_dig -1 // threshold: uint8
	itob
	extract 7 1
	btoi
	frame_bury 0 // t: uint64

	// src/arcs/arc55.algo.ts:215
	// assert(t)
	frame_dig 0 // t: uint64
	assert

	// src/arcs/arc55.algo.ts:216
	// this._threshold.value = t
	byte 0x5f7468726573686f6c64 // "_threshold"
	frame_dig 0 // t: uint64
	app_global_put

	// src/arcs/arc55.algo.ts:218
	// this._nonce.value = 0
	byte 0x5f6e6f6e6365 // "_nonce"
	int 0
	app_global_put

	// src/arcs/arc55.algo.ts:222
	// pIndex = 0
	int 0
	frame_bury 1 // pIndex: uint64

while_0:
	// src/arcs/arc55.algo.ts:223
	// this._indexToAddress(pIndex).exists
	txna Applications 0
	frame_dig 1 // pIndex: uint64
	itob
	app_global_get_ex
	swap
	pop
	bz while_0_end

	// src/arcs/arc55.algo.ts:224
	// address = this._indexToAddress(pIndex).value
	frame_dig 1 // pIndex: uint64
	itob
	app_global_get
	frame_bury 2 // address: address

	// src/arcs/arc55.algo.ts:228
	// this._addressCount(address).delete
	frame_dig 2 // address: address
	app_global_del

	// src/arcs/arc55.algo.ts:229
	// this._indexToAddress(pIndex).delete
	frame_dig 1 // pIndex: uint64
	itob
	app_global_del

	// src/arcs/arc55.algo.ts:230
	// pIndex += 1
	frame_dig 1 // pIndex: uint64
	int 1
	+
	frame_bury 1 // pIndex: uint64
	b while_0

while_0_end:
	// src/arcs/arc55.algo.ts:234
	// nIndex = 0
	int 0
	frame_bury 3 // nIndex: uint64

while_1:
	// src/arcs/arc55.algo.ts:236
	// nIndex < addresses.length
	frame_dig 3 // nIndex: uint64
	frame_dig -2 // addresses: Address[]
	len
	int 32
	/
	<
	bz while_1_end

	// src/arcs/arc55.algo.ts:237
	// address = addresses[nIndex]
	frame_dig -2 // addresses: Address[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 3 // nIndex: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	frame_bury 4 // address: Address

	// src/arcs/arc55.algo.ts:240
	// this._indexToAddress(nIndex).value = address
	frame_dig 3 // nIndex: uint64
	itob
	frame_dig 4 // address: Address
	app_global_put

	// src/arcs/arc55.algo.ts:244
	// this._addressCount(address).value += 1
	frame_dig 4 // address: Address
	app_global_get
	int 1
	+
	frame_dig 4 // address: Address
	swap
	app_global_put

	// src/arcs/arc55.algo.ts:246
	// nIndex += 1
	frame_dig 3 // nIndex: uint64
	int 1
	+
	frame_bury 3 // nIndex: uint64
	b while_1

while_1_end:
	retsub

// arc55_newTransactionGroup()uint64
abi_route_arc55_newTransactionGroup:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc55_newTransactionGroup()uint64
	callsub arc55_newTransactionGroup
	itob
	concat
	log
	int 1
	return

// arc55_newTransactionGroup(): uint64
//
// Generate a new transaction group nonce for holding pending transactions
// @returns transactionGroup Transaction Group nonce
arc55_newTransactionGroup:
	proto 0 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// src/arcs/arc55.algo.ts:255
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:257
	// n = this._nonce.value + 1
	byte 0x5f6e6f6e6365 // "_nonce"
	app_global_get
	int 1
	+
	frame_bury 0 // n: uint64

	// src/arcs/arc55.algo.ts:258
	// this._nonce.value = n
	byte 0x5f6e6f6e6365 // "_nonce"
	frame_dig 0 // n: uint64
	app_global_put

	// src/arcs/arc55.algo.ts:260
	// return n;
	frame_dig 0 // n: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// arc55_addTransaction(pay,uint64,uint8,byte[])void
abi_route_arc55_addTransaction:
	// transaction: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// index: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// costs: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute arc55_addTransaction(pay,uint64,uint8,byte[])void
	callsub arc55_addTransaction
	int 1
	return

// arc55_addTransaction(costs: PayTxn, transactionGroup: uint64, index: uint8, transaction: bytes): void
//
// Add a transaction to an existing group. Only one transaction should be included per call
// @param costs Minimum Balance Requirement for associated box storage costs: (2500) + (400 * (9 + transaction.length))
// @param transactionGroup Transaction Group nonce
// @param index Transaction position within atomic group to add
// @param transaction Transaction to add
arc55_addTransaction:
	proto 4 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 4

	// src/arcs/arc55.algo.ts:276
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:278
	// assert(transactionGroup)
	frame_dig -2 // transactionGroup: uint64
	assert

	// src/arcs/arc55.algo.ts:279
	// assert(transactionGroup <= this._nonce.value)
	frame_dig -2 // transactionGroup: uint64
	byte 0x5f6e6f6e6365 // "_nonce"
	app_global_get
	<=
	assert

	// src/arcs/arc55.algo.ts:281
	// transactionBox: TransactionGroup = {
	//             nonce: transactionGroup,
	//             index: index,
	//         }
	frame_dig -2 // transactionGroup: uint64
	itob
	frame_dig -3 // index: uint8
	itob
	extract 7 1
	concat
	frame_bury 0 // transactionBox: TransactionGroup

	// src/arcs/arc55.algo.ts:289
	// transactionData = transaction
	frame_dig -4 // transaction: bytes
	frame_bury 1 // transactionData: byte[]

	// src/arcs/arc55.algo.ts:290
	// groupPosition = this.txn.groupIndex + 1
	txn GroupIndex
	int 1
	+
	frame_bury 2 // groupPosition: uint64

	// if2_condition
	// src/arcs/arc55.algo.ts:291
	// groupPosition < globals.groupSize
	frame_dig 2 // groupPosition: uint64
	global GroupSize
	<
	bz if2_end

// if2_consequent
do_while_0:
	// if3_condition
	// src/arcs/arc55.algo.ts:294
	// this.txnGroup[groupPosition].applicationID === this.txn.applicationID
	//                     && this.txnGroup[groupPosition].applicationArgs[0] === method("arc55_addTransactionContinued(byte[])void")
	frame_dig 2 // groupPosition: uint64
	gtxns ApplicationID
	txn ApplicationID
	==
	dup
	bz skip_and0
	frame_dig 2 // groupPosition: uint64
	gtxns ApplicationArgs 0
	method "arc55_addTransactionContinued(byte[])void"
	==
	&&

skip_and0:
	bz if3_end

	// if3_consequent
	// src/arcs/arc55.algo.ts:297
	// transactionData += extract3(this.txnGroup[groupPosition].applicationArgs[1], 2, 0)
	frame_dig 1 // transactionData: byte[]
	frame_dig 2 // groupPosition: uint64
	gtxns ApplicationArgs 1
	extract 2 0
	concat
	frame_bury 1 // transactionData: byte[]

if3_end:
	// src/arcs/arc55.algo.ts:299
	// groupPosition += 1
	frame_dig 2 // groupPosition: uint64
	int 1
	+
	frame_bury 2 // groupPosition: uint64

	// src/arcs/arc55.algo.ts:300
	// groupPosition < globals.groupSize
	frame_dig 2 // groupPosition: uint64
	global GroupSize
	<
	bnz do_while_0

if2_end:
	// src/arcs/arc55.algo.ts:303
	// mbrTxnIncrease = this.arc55_mbrTxnIncrease(transactionData.length)
	frame_dig 1 // transactionData: byte[]
	len
	callsub arc55_mbrTxnIncrease
	frame_bury 3 // mbrTxnIncrease: uint64

	// src/arcs/arc55.algo.ts:305
	// verifyTxn(costs, {
	//             receiver: this.app.address,
	//             amount: { greaterThanEqualTo: mbrTxnIncrease }
	//         })
	// verify receiver
	frame_dig -1 // costs: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // costs: PayTxn
	gtxns Amount
	frame_dig 3 // mbrTxnIncrease: uint64
	>=
	assert

	// src/arcs/arc55.algo.ts:312
	// this._transactions(transactionBox).value = transactionData
	frame_dig 0 // transactionBox: TransactionGroup
	dup
	box_del
	pop
	frame_dig 1 // transactionData: byte[]
	box_put

	// src/arcs/arc55.algo.ts:315
	// this.TransactionAdded.log({
	//             transactionGroup: transactionGroup,
	//             transactionIndex: index
	//         })
	byte 0x1849a594 // TransactionAdded(uint64,uint8)
	frame_dig -2 // transactionGroup: uint64
	itob
	frame_dig -3 // index: uint8
	itob
	extract 7 1
	concat
	concat
	log
	retsub

// arc55_addTransactionContinued(byte[])void
abi_route_arc55_addTransactionContinued:
	// transaction: byte[]
	txna ApplicationArgs 1
	extract 2 0

	// execute arc55_addTransactionContinued(byte[])void
	callsub arc55_addTransactionContinued
	int 1
	return

// arc55_addTransactionContinued(transaction: bytes): void
arc55_addTransactionContinued:
	proto 1 0

	// src/arcs/arc55.algo.ts:324
	// this.onlySigner()
	callsub onlySigner
	retsub

// arc55_removeTransaction(uint64,uint8)void
abi_route_arc55_removeTransaction:
	// index: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	btoi

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_removeTransaction(uint64,uint8)void
	callsub arc55_removeTransaction
	int 1
	return

// arc55_removeTransaction(transactionGroup: uint64, index: uint8): void
//
// Remove transaction from the app. The MBR associated with the transaction will be returned to the transaction sender.
// @param transactionGroup Transaction Group nonce
// @param index Transaction position within atomic group to remove
arc55_removeTransaction:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// src/arcs/arc55.algo.ts:336
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:338
	// transactionBox: TransactionGroup = {
	//             nonce: transactionGroup,
	//             index: index,
	//         }
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // index: uint8
	itob
	extract 7 1
	concat
	frame_bury 0 // transactionBox: TransactionGroup

	// src/arcs/arc55.algo.ts:343
	// txnLength = this._transactions(transactionBox).size
	frame_dig 0 // transactionBox: TransactionGroup
	box_len
	assert
	frame_bury 1 // txnLength: uint64

	// src/arcs/arc55.algo.ts:344
	// this._transactions(transactionBox).delete
	frame_dig 0 // transactionBox: TransactionGroup
	box_del

	// src/arcs/arc55.algo.ts:349
	// mbrTxnDecrease = (2500) + (400 * (9 + txnLength))
	int 2500
	int 400
	int 9
	frame_dig 1 // txnLength: uint64
	+
	*
	+
	frame_bury 2 // mbrTxnDecrease: uint64

	// src/arcs/arc55.algo.ts:351
	// sendPayment({
	//             receiver: this.txn.sender,
	//             amount: mbrTxnDecrease
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/arcs/arc55.algo.ts:352
	// receiver: this.txn.sender
	txn Sender
	itxn_field Receiver

	// src/arcs/arc55.algo.ts:353
	// amount: mbrTxnDecrease
	frame_dig 2 // mbrTxnDecrease: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/arcs/arc55.algo.ts:357
	// this.TransactionRemoved.log({
	//             transactionGroup: transactionGroup,
	//             transactionIndex: index
	//         })
	byte 0x3e9b2ca5 // TransactionRemoved(uint64,uint8)
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // index: uint8
	itob
	extract 7 1
	concat
	concat
	log
	retsub

// arc55_setSignatures(pay,uint64,byte[64][])void
abi_route_arc55_setSignatures:
	// signatures: byte[64][]
	txna ApplicationArgs 2
	extract 2 0

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// costs: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute arc55_setSignatures(pay,uint64,byte[64][])void
	callsub arc55_setSignatures
	int 1
	return

// arc55_setSignatures(costs: PayTxn, transactionGroup: uint64, signatures: bytes64[]): void
//
// Set signatures for a particular transaction group. Signatures must be included as an array of byte-arrays
// @param costs Minimum Balance Requirement for associated box storage costs: (2500) + (400 * (40 + signatures.length))
// @param transactionGroup Transaction Group nonce
// @param signatures Array of signatures
arc55_setSignatures:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// src/arcs/arc55.algo.ts:374
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:376
	// mbrSigIncrease = this.arc55_mbrSigIncrease(signatures.length * 64)
	frame_dig -3 // signatures: bytes64[]
	len
	int 64
	/
	int 64
	*
	callsub arc55_mbrSigIncrease
	frame_bury 0 // mbrSigIncrease: uint64

	// src/arcs/arc55.algo.ts:378
	// verifyTxn(costs, {
	//             receiver: this.app.address,
	//             amount: { greaterThanEqualTo: mbrSigIncrease }
	//         })
	// verify receiver
	frame_dig -1 // costs: PayTxn
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // costs: PayTxn
	gtxns Amount
	frame_dig 0 // mbrSigIncrease: uint64
	>=
	assert

	// src/arcs/arc55.algo.ts:383
	// signatureBox: TransactionSignatures = {
	//             nonce: transactionGroup,
	//             address: this.txn.sender
	//         }
	frame_dig -2 // transactionGroup: uint64
	itob
	txn Sender
	concat
	frame_bury 1 // signatureBox: TransactionSignatures

	// src/arcs/arc55.algo.ts:388
	// this._signatures(signatureBox).value = signatures
	frame_dig 1 // signatureBox: TransactionSignatures
	dup
	box_del
	pop
	frame_dig -3 // signatures: bytes64[]
	dup
	len
	int 64
	/
	itob
	extract 6 2
	swap
	concat
	box_put

	// src/arcs/arc55.algo.ts:391
	// this.SignatureSet.log({
	//             transactionGroup: transactionGroup,
	//             signer: this.txn.sender
	//         })
	byte 0xecfbcb33 // SignatureSet(uint64,address)
	frame_dig -2 // transactionGroup: uint64
	itob
	txn Sender
	concat
	concat
	log
	retsub

// arc55_clearSignatures(uint64,address)void
abi_route_arc55_clearSignatures:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_clearSignatures(uint64,address)void
	callsub arc55_clearSignatures
	int 1
	return

// arc55_clearSignatures(transactionGroup: uint64, address: Address): void
//
// Clear signatures for an address. Be aware this only removes it from the current state of the ledger, and indexers will still know and could use your signature
// @param transactionGroup Transaction Group nonce
// @param address Address whose signatures to clear
arc55_clearSignatures:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 3

	// src/arcs/arc55.algo.ts:406
	// this.onlySigner()
	callsub onlySigner

	// src/arcs/arc55.algo.ts:408
	// signatureBox: TransactionSignatures = {
	//             nonce: transactionGroup,
	//             address: address
	//         }
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // address: Address
	concat
	frame_bury 0 // signatureBox: TransactionSignatures

	// src/arcs/arc55.algo.ts:413
	// sigLength = this._signatures(signatureBox).size
	frame_dig 0 // signatureBox: TransactionSignatures
	box_len
	assert
	frame_bury 1 // sigLength: uint64

	// src/arcs/arc55.algo.ts:414
	// this._signatures(signatureBox).delete
	frame_dig 0 // signatureBox: TransactionSignatures
	box_del

	// src/arcs/arc55.algo.ts:419
	// mbrSigDecrease = (2500) + (400 * (40 + sigLength))
	int 2500
	int 400
	int 40
	frame_dig 1 // sigLength: uint64
	+
	*
	+
	frame_bury 2 // mbrSigDecrease: uint64

	// src/arcs/arc55.algo.ts:421
	// sendPayment({
	//             receiver: address,
	//             amount: mbrSigDecrease
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/arcs/arc55.algo.ts:422
	// receiver: address
	frame_dig -2 // address: Address
	itxn_field Receiver

	// src/arcs/arc55.algo.ts:423
	// amount: mbrSigDecrease
	frame_dig 2 // mbrSigDecrease: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit

	// src/arcs/arc55.algo.ts:427
	// this.SignatureSet.log({
	//             transactionGroup: transactionGroup,
	//             signer: address
	//         })
	byte 0xecfbcb33 // SignatureSet(uint64,address)
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // address: Address
	concat
	concat
	log
	retsub

// deploy()uint64
abi_route_deploy:
	// The ABI return prefix
	byte 0x151f7c75

	// execute deploy()uint64
	callsub deploy
	itob
	concat
	log
	int 1
	return

// deploy(): Application
//
// Deploy a new On-Chain Msig App.
// @returns Msig App Application ID
deploy:
	proto 0 1

	// src/msig-app.algo.ts:11
	// return globals.currentApplicationID;
	global CurrentApplicationID
	retsub

// update()void
abi_route_update:
	// execute update()void
	callsub update
	int 1
	return

// update(): void
//
// Update the application
update:
	proto 0 0

	// src/msig-app.algo.ts:19
	// this.onlyCreator()
	callsub onlyCreator
	retsub

// destroy()void
abi_route_destroy:
	// execute destroy()void
	callsub destroy
	int 1
	return

// destroy(): void
//
// Destroy the application and return funds to creator address. All transactions must be removed before calling destroy
destroy:
	proto 0 0

	// src/msig-app.algo.ts:27
	// this.onlyCreator()
	callsub onlyCreator

	// src/msig-app.algo.ts:29
	// sendPayment({
	//             amount: 0,
	//             receiver: globals.creatorAddress,
	//             closeRemainderTo: globals.creatorAddress,
	//             fee: 0,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/msig-app.algo.ts:30
	// amount: 0
	int 0
	itxn_field Amount

	// src/msig-app.algo.ts:31
	// receiver: globals.creatorAddress
	global CreatorAddress
	itxn_field Receiver

	// src/msig-app.algo.ts:32
	// closeRemainderTo: globals.creatorAddress
	global CreatorAddress
	itxn_field CloseRemainderTo

	// src/msig-app.algo.ts:33
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

create_NoOp:
	method "deploy()uint64"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "arc55_threshold()uint64"
	method "arc55_transaction(uint64,uint8)byte[]"
	method "arc55_signatures(uint64,address)byte[64][]"
	method "arc55_signerByIndex(uint64)address"
	method "arc55_isSigner(address)bool"
	method "arc55_mbrSigIncrease(uint64)uint64"
	method "arc55_mbrTxnIncrease(uint64)uint64"
	method "arc55_setup(uint8,address[])void"
	method "arc55_newTransactionGroup()uint64"
	method "arc55_addTransaction(pay,uint64,uint8,byte[])void"
	method "arc55_addTransactionContinued(byte[])void"
	method "arc55_removeTransaction(uint64,uint8)void"
	method "arc55_setSignatures(pay,uint64,byte[64][])void"
	method "arc55_clearSignatures(uint64,address)void"
	txna ApplicationArgs 0
	match abi_route_arc55_threshold abi_route_arc55_transaction abi_route_arc55_signatures abi_route_arc55_signerByIndex abi_route_arc55_isSigner abi_route_arc55_mbrSigIncrease abi_route_arc55_mbrTxnIncrease abi_route_arc55_setup abi_route_arc55_newTransactionGroup abi_route_arc55_addTransaction abi_route_arc55_addTransactionContinued abi_route_arc55_removeTransaction abi_route_arc55_setSignatures abi_route_arc55_clearSignatures
	err

call_UpdateApplication:
	method "update()void"
	txna ApplicationArgs 0
	match abi_route_update
	err

call_DeleteApplication:
	method "destroy()void"
	txna ApplicationArgs 0
	match abi_route_destroy
	err