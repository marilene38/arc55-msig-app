#pragma version 9

// This TEAL was generated by TEALScript v0.66.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its respective branch will be "NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_UpdateApplication call_DeleteApplication

NOT_IMPLEMENTED:
	err

is_creator:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 0 1

	// src/msig-app.algo.ts:34
	// return this.txn.sender === globals.creatorAddress;
	txn Sender
	global CreatorAddress
	==
	retsub

is_signer:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 0 1

	// src/msig-app.algo.ts:38
	// return this.addressCount(this.txn.sender).exists as boolean;
	txna Applications 0
	txn Sender
	app_global_get_ex
	swap
	pop
	retsub

// deploy()uint64
//
// Deploy a new On-Chain Msig App.
// @returns Msig App Application ID
abi_route_deploy:
	// The ABI return prefix
	byte 0x151f7c75

	// execute deploy()uint64
	callsub deploy
	itob
	concat
	log
	int 1
	return

deploy:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 0 1

	// src/msig-app.algo.ts:49
	// return globals.currentApplicationID;
	global CurrentApplicationID
	retsub

// update()void
//
// Update the application
abi_route_update:
	// execute update()void
	callsub update
	int 1
	return

update:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 0 0

	// src/msig-app.algo.ts:57
	// assert(this.is_creator())
	callsub is_creator
	assert
	retsub

// destroy()void
//
// Destroy the application and return funds to creator address. All transactions must be removed before calling destroy
abi_route_destroy:
	// execute destroy()void
	callsub destroy
	int 1
	return

destroy:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 0 0

	// src/msig-app.algo.ts:65
	// assert(this.is_creator())
	callsub is_creator
	assert

	// src/msig-app.algo.ts:67
	// sendPayment({
	//             amount: 0,
	//             receiver: globals.creatorAddress,
	//             closeRemainderTo: globals.creatorAddress,
	//             fee: 0,
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/msig-app.algo.ts:68
	// amount: 0
	int 0
	itxn_field Amount

	// src/msig-app.algo.ts:69
	// receiver: globals.creatorAddress
	global CreatorAddress
	itxn_field Receiver

	// src/msig-app.algo.ts:70
	// closeRemainderTo: globals.creatorAddress
	global CreatorAddress
	itxn_field CloseRemainderTo

	// src/msig-app.algo.ts:71
	// fee: 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

// arc55_setup(address[],uint8)void
//
// Setup On-Chain Msig App. This can only be called whilst no transaction groups have been created.
// @param threshold Initial multisig threshold, must be greater than 0
// @param addresses Array of addresses that make up the multisig
abi_route_arc55_setup:
	// addresses: address[]
	txna ApplicationArgs 2
	extract 2 0

	// threshold: uint8
	txna ApplicationArgs 1
	dup
	len
	int 1
	==
	assert

	// execute arc55_setup(address[],uint8)void
	callsub arc55_setup
	int 1
	return

arc55_setup:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 0; byte 0x; dupn 2

	// src/msig-app.algo.ts:85
	// assert(!this.nonce.value)
	byte 0x6e // "n"
	app_global_get
	!
	assert

	// src/msig-app.algo.ts:86
	// assert(this.is_creator())
	callsub is_creator
	assert

	// src/msig-app.algo.ts:88
	// t: uint<64> = btoi(rawBytes(threshold))
	frame_dig -1 // threshold: uint8
	btoi
	frame_bury 0 // t: uint64

	// src/msig-app.algo.ts:89
	// assert(t)
	frame_dig 0 // t: uint64
	assert

	// src/msig-app.algo.ts:90
	// this.threshold.value = t
	byte 0x74 // "t"
	frame_dig 0 // t: uint64
	app_global_put

	// src/msig-app.algo.ts:92
	// this.nonce.value = 0
	byte 0x6e // "n"
	int 0
	app_global_put

	// src/msig-app.algo.ts:94
	// index = 0
	int 0
	frame_bury 1 // index: uint64

while_0:
	frame_dig 1 // index: uint64

	// src/msig-app.algo.ts:96
	// addresses.length
	frame_dig -2 // addresses: address[]
	len
	int 32
	/
	<
	bz while_0_end

	// src/msig-app.algo.ts:97
	// address = addresses[index]
	frame_dig -2 // addresses: address[]
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // index: uint64
	int 32
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 32
	extract3
	frame_bury 2 // address: address

	// src/msig-app.algo.ts:100
	// this.indexToAddress(index).value = address
	frame_dig 1 // index: uint64
	itob
	frame_dig 2 // address: address
	app_global_put

	// src/msig-app.algo.ts:104
	// this.addressCount(address).value = this.addressCount(address).value + 1
	frame_dig 2 // address: address
	frame_dig 2 // address: address
	app_global_get
	int 1
	+
	app_global_put

	// src/msig-app.algo.ts:106
	// index = index + 1
	frame_dig 1 // index: uint64
	int 1
	+
	frame_bury 1 // index: uint64
	b while_0

while_0_end:
	retsub

// arc55_newTransactionGroup()uint64
abi_route_arc55_newTransactionGroup:
	// The ABI return prefix
	byte 0x151f7c75

	// execute arc55_newTransactionGroup()uint64
	callsub arc55_newTransactionGroup
	itob
	concat
	log
	int 1
	return

arc55_newTransactionGroup:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 0 1; byte 0x

	// src/msig-app.algo.ts:111
	// assert(this.is_signer())
	callsub is_signer
	assert

	// src/msig-app.algo.ts:113
	// n = this.nonce.value + 1
	byte 0x6e // "n"
	app_global_get
	int 1
	+
	frame_bury 0 // n: uint64

	// src/msig-app.algo.ts:114
	// this.nonce.value = n
	byte 0x6e // "n"
	frame_dig 0 // n: uint64
	app_global_put

	// src/msig-app.algo.ts:116
	// return n;
	frame_dig 0 // n: uint64

	// set the subroutine return value
	frame_bury 0
	retsub

// arc55_addTransaction(bytes,uint8,uint64,pay)void
//
// Add a transaction to an existing group. Only one transaction should be included per call
// @param transactionGroup Transaction Group nonce
// @param index Transaction position within atomic group to add
// @param transaction Transaction to add
abi_route_arc55_addTransaction:
	// transaction: byte[]
	txna ApplicationArgs 3
	extract 2 0

	// index: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// costs: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute arc55_addTransaction(bytes,uint8,uint64,pay)void
	callsub arc55_addTransaction
	int 1
	return

arc55_addTransaction:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 4 0; byte 0x; dupn 1

	// src/msig-app.algo.ts:133
	// assert(this.is_signer())
	callsub is_signer
	assert

	// src/msig-app.algo.ts:138
	// mbrTxnIncrease = (2500) + (400 * (9 + transaction.length))
	int 2500
	int 400
	int 9
	frame_dig -4 // transaction: bytes
	len
	+
	*
	+
	frame_bury 0 // mbrTxnIncrease: uint64

	// src/msig-app.algo.ts:140
	// verifyTxn(costs, {
	//             receiver: this.app.address,
	//             amount: mbrTxnIncrease
	//         })
	// verify receiver
	frame_dig -1 // costs: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // costs: pay
	gtxns Amount
	frame_dig 0 // mbrTxnIncrease: uint64
	==
	assert

	// src/msig-app.algo.ts:145
	// assert(transactionGroup)
	frame_dig -2 // transactionGroup: uint64
	assert

	// src/msig-app.algo.ts:146
	// assert(transactionGroup <= this.nonce.value)
	frame_dig -2 // transactionGroup: uint64
	byte 0x6e // "n"
	app_global_get
	<=
	assert

	// src/msig-app.algo.ts:148
	// transactionBox: TransactionGroup = {
	//             nonce: transactionGroup,
	//             index: index,
	//         }
	frame_dig -2 // transactionGroup: uint64
	itob
	frame_dig -3 // index: uint8
	concat
	frame_bury 1 // transactionBox: TransactionGroup

	// src/msig-app.algo.ts:155
	// this.transactions(transactionBox).value = transaction
	frame_dig 1 // transactionBox: TransactionGroup
	dup
	box_del
	pop
	frame_dig -4 // transaction: bytes
	box_put
	retsub

// arc55_removeTransaction(uint8,uint64)void
//
// Remove transaction from the app. Unlike signatures which will remove all previous signatures when a new one is added, you must clear all previous transactions if you want to reuse the same app
// @param transactionGroup Transaction Group nonce
// @param index Transaction position within atomic group to remove
abi_route_arc55_removeTransaction:
	// index: uint8
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_removeTransaction(uint8,uint64)void
	callsub arc55_removeTransaction
	int 1
	return

arc55_removeTransaction:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 0; byte 0x

	// src/msig-app.algo.ts:167
	// assert(this.is_signer())
	callsub is_signer
	assert

	// src/msig-app.algo.ts:169
	// transactionBox: TransactionGroup = {
	//             nonce: transactionGroup,
	//             index: index,
	//         }
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // index: uint8
	concat
	frame_bury 0 // transactionBox: TransactionGroup

	// src/msig-app.algo.ts:176
	// this.transactions(transactionBox).delete
	frame_dig 0 // transactionBox: TransactionGroup
	box_del
	retsub

// arc55_setSignatures(bytes[],uint64,pay)void
//
// Set signatures for a particular transaction group. Signatures must be included as an array of byte-arrays
// @param transactionGroup Transaction Group nonce
// @param signatures Array of signatures
abi_route_arc55_setSignatures:
	// signatures: byte[][]
	txna ApplicationArgs 2

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// costs: pay
	txn GroupIndex
	int 1
	-
	dup
	gtxns TypeEnum
	int pay
	==
	assert

	// execute arc55_setSignatures(bytes[],uint64,pay)void
	callsub arc55_setSignatures
	int 1
	return

arc55_setSignatures:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 3 0; byte 0x; dupn 1

	// src/msig-app.algo.ts:189
	// assert(this.is_signer())
	callsub is_signer
	assert

	// src/msig-app.algo.ts:194
	// mbrSigIncrease = (2500) + (400 * (40 + signatures.length))
	int 2500
	int 400
	int 40
	frame_dig -3 // signatures: bytes[]
	extract 0 2
	btoi
	+
	*
	+
	frame_bury 0 // mbrSigIncrease: uint64

	// src/msig-app.algo.ts:196
	// verifyTxn(costs, {
	//             receiver: this.app.address,
	//             amount: mbrSigIncrease,
	//         })
	// verify receiver
	frame_dig -1 // costs: pay
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// verify amount
	frame_dig -1 // costs: pay
	gtxns Amount
	frame_dig 0 // mbrSigIncrease: uint64
	==
	assert

	// src/msig-app.algo.ts:201
	// signatureBox: TransactionSignatures = {
	//             nonce: transactionGroup,
	//             address: this.txn.sender
	//         }
	frame_dig -2 // transactionGroup: uint64
	itob
	txn Sender
	concat
	frame_bury 1 // signatureBox: TransactionSignatures

	// src/msig-app.algo.ts:206
	// this.signatures(signatureBox).value = signatures
	frame_dig 1 // signatureBox: TransactionSignatures
	dup
	box_del
	pop
	frame_dig -3 // signatures: bytes[]
	box_put
	retsub

// arc55_clearSignatures(address,uint64)void
//
// Clear signatures for an address. Be aware this only removes it from the current state of the ledger, and indexers will still know and could use your signature
// @param address Address whose signatures to clear
abi_route_arc55_clearSignatures:
	// address: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// transactionGroup: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc55_clearSignatures(address,uint64)void
	callsub arc55_clearSignatures
	int 1
	return

arc55_clearSignatures:
	// Setup the frame for args and return value. Use empty bytes to create space on the stack for local variables if necessary
	proto 2 0; byte 0x; dupn 2

	// src/msig-app.algo.ts:217
	// assert(this.is_signer())
	callsub is_signer
	assert

	// src/msig-app.algo.ts:219
	// signatureBox: TransactionSignatures = {
	//             nonce: transactionGroup,
	//             address: address
	//         }
	frame_dig -1 // transactionGroup: uint64
	itob
	frame_dig -2 // address: address
	concat
	frame_bury 0 // signatureBox: TransactionSignatures

	// src/msig-app.algo.ts:224
	// sigLength = this.signatures(signatureBox).size
	frame_dig 0 // signatureBox: TransactionSignatures
	box_len
	assert
	frame_bury 1 // sigLength: uint64

	// src/msig-app.algo.ts:225
	// this.signatures(signatureBox).delete
	frame_dig 0 // signatureBox: TransactionSignatures
	box_del

	// src/msig-app.algo.ts:230
	// mbrSigDecrease = (2500) + (400 * (40 + sigLength))
	int 2500
	int 400
	int 40
	frame_dig 1 // sigLength: uint64
	+
	*
	+
	frame_bury 2 // mbrSigDecrease: uint64

	// src/msig-app.algo.ts:232
	// sendPayment({
	//             receiver: address,
	//             amount: mbrSigDecrease
	//         })
	itxn_begin
	int pay
	itxn_field TypeEnum

	// src/msig-app.algo.ts:233
	// receiver: address
	frame_dig -2 // address: address
	itxn_field Receiver

	// src/msig-app.algo.ts:234
	// amount: mbrSigDecrease
	frame_dig 2 // mbrSigDecrease: uint64
	itxn_field Amount

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	retsub

create_NoOp:
	method "deploy()uint64"
	txna ApplicationArgs 0
	match abi_route_deploy
	err

call_NoOp:
	method "arc55_setup(uint8,address[])void"
	method "arc55_newTransactionGroup()uint64"
	method "arc55_addTransaction(pay,uint64,uint8,byte[])void"
	method "arc55_removeTransaction(uint64,uint8)void"
	method "arc55_setSignatures(pay,uint64,byte[][])void"
	method "arc55_clearSignatures(uint64,address)void"
	txna ApplicationArgs 0
	match abi_route_arc55_setup abi_route_arc55_newTransactionGroup abi_route_arc55_addTransaction abi_route_arc55_removeTransaction abi_route_arc55_setSignatures abi_route_arc55_clearSignatures
	err

call_UpdateApplication:
	method "update()void"
	txna ApplicationArgs 0
	match abi_route_update
	err

call_DeleteApplication:
	method "destroy()void"
	txna ApplicationArgs 0
	match abi_route_destroy
	err