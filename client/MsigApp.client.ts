/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner, modelsv2 } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "arc55_threshold()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_nextTransactionGroup()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_transaction(uint64,uint8)byte[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_signatures(uint64,address)byte[64][]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_signerByIndex(uint64)address": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_isSigner(address)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_mbrSigIncrease(uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_mbrTxnIncrease(uint64)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_setup(uint8,address[])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_newTransactionGroup()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_addTransaction(pay,uint64,uint8,byte[])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_addTransactionContinued(byte[])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_removeTransaction(uint64,uint8)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_setSignatures(pay,uint64,byte[64][])void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "arc55_clearSignatures(uint64,address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "deploy()uint64": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "update()void": {
      "call_config": {
        "update_application": "CALL"
      }
    },
    "destroy()void": {
      "call_config": {
        "delete_application": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "_threshold": {
          "type": "uint64",
          "key": "_threshold"
        },
        "_nonce": {
          "type": "uint64",
          "key": "_nonce"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 31,
      "num_uints": 33
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjc2LjEKLy8gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29yYW5kZm91bmRhdGlvbi9URUFMU2NyaXB0CgovLyBUaGlzIGNvbnRyYWN0IGlzIGNvbXBsaWFudCB3aXRoIGFuZC9vciBpbXBsZW1lbnRzIHRoZSBmb2xsb3dpbmcgQVJDczogWyBBUkM0IF0KCi8vIFRoZSBmb2xsb3dpbmcgdGVuIGxpbmVzIG9mIFRFQUwgaGFuZGxlIGluaXRpYWwgcHJvZ3JhbSBmbG93Ci8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIHRvIG1ha2UgaXQgZWFzeSBmb3IgYW55b25lIHRvIHBhcnNlIHRoZSBzdGFydCBvZiB0aGUgcHJvZ3JhbSBhbmQgZGV0ZXJtaW5lIGlmIGEgc3BlY2lmaWMgYWN0aW9uIGlzIGFsbG93ZWQKLy8gSGVyZSwgYWN0aW9uIHJlZmVycyB0byB0aGUgT25Db21wbGV0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHdoZXRoZXIgdGhlIGFwcCBpcyBiZWluZyBjcmVhdGVkIG9yIGNhbGxlZAovLyBFdmVyeSBwb3NzaWJsZSBhY3Rpb24gZm9yIHRoaXMgY29udHJhY3QgaXMgcmVwcmVzZW50ZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQKLy8gSWYgdGhlIGFjdGlvbiBpcyBub3QgaW1wbG1lbnRlZCBpbiB0aGUgY29udHJhY3QsIGl0cyByZXNwZWN0aXZlIGJyYW5jaCB3aWxsIGJlICJOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQppbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggY2FsbF9Ob09wIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIGNhbGxfVXBkYXRlQXBwbGljYXRpb24gY2FsbF9EZWxldGVBcHBsaWNhdGlvbiBjcmVhdGVfTm9PcCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVEIE5PVF9JTVBMRU1FTlRFRCBOT1RfSU1QTEVNRU5URUQgTk9UX0lNUExFTUVOVEVECgpOT1RfSU1QTEVNRU5URUQ6CgllcnIKCi8vIG9ubHlTaWduZXIoKTogdm9pZAovLwovLyBDaGVjayB0aGUgdHJhbnNhY3Rpb24gc2VuZGVyIGlzIGEgc2lnbmVyIGZvciB0aGUgbXVsdGlzaWcKb25seVNpZ25lcjoKCXByb3RvIDAgMAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6ODEKCS8vIGFzc2VydCh0aGlzLl9hZGRyZXNzQ291bnQodGhpcy50eG4uc2VuZGVyKS5leGlzdHMpCgl0eG5hIEFwcGxpY2F0aW9ucyAwCgl0eG4gU2VuZGVyCglhcHBfZ2xvYmFsX2dldF9leAoJc3dhcAoJcG9wCglhc3NlcnQKCXJldHN1YgoKLy8gb25seUNyZWF0b3IoKTogdm9pZAovLwovLyBDaGVjayB0aGUgdHJhbnNhY3Rpb24gc2VuZGVyIGlzIHRoZSBjb250cmFjdCBjcmVhdG9yCm9ubHlDcmVhdG9yOgoJcHJvdG8gMCAwCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czo4OAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoJcmV0c3ViCgovLyBhcmM1NV90aHJlc2hvbGQoKXVpbnQ2NAphYmlfcm91dGVfYXJjNTVfdGhyZXNob2xkOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGFyYzU1X3RocmVzaG9sZCgpdWludDY0CgljYWxsc3ViIGFyYzU1X3RocmVzaG9sZAoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGFyYzU1X3RocmVzaG9sZCgpOiB1aW50NjQKLy8KLy8gUmV0cmlldmUgdGhlIHNpZ25hdHVyZSB0aHJlc2hvbGQgcmVxdWlyZWQgZm9yIHRoZSBtdWx0aXNpZ25hdHVyZSB0byBiZSBzdWJtaXR0ZWQKLy8gQHJldHVybnMgTXVsdGlzaWduYXR1cmUgdGhyZXNob2xkCmFyYzU1X3RocmVzaG9sZDoKCXByb3RvIDAgMQoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6OTkKCS8vIHJldHVybiB0aGlzLl90aHJlc2hvbGQudmFsdWU7CglieXRlIDB4NWY3NDY4NzI2NTczNjg2ZjZjNjQgLy8gIl90aHJlc2hvbGQiCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBhcmM1NV9uZXh0VHJhbnNhY3Rpb25Hcm91cCgpdWludDY0CmFiaV9yb3V0ZV9hcmM1NV9uZXh0VHJhbnNhY3Rpb25Hcm91cDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBhcmM1NV9uZXh0VHJhbnNhY3Rpb25Hcm91cCgpdWludDY0CgljYWxsc3ViIGFyYzU1X25leHRUcmFuc2FjdGlvbkdyb3VwCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYXJjNTVfbmV4dFRyYW5zYWN0aW9uR3JvdXAoKTogdWludDY0Ci8vCi8vCi8vIEByZXR1cm5zIE5leHQgZXhwZWN0ZWQgVHJhbnNhY3Rpb24gR3JvdXAgbm9uY2UKYXJjNTVfbmV4dFRyYW5zYWN0aW9uR3JvdXA6Cglwcm90byAwIDEKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjEwOAoJLy8gcmV0dXJuIHRoaXMuX25vbmNlLnZhbHVlICsgMTsKCWJ5dGUgMHg1ZjZlNmY2ZTYzNjUgLy8gIl9ub25jZSIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMQoJKwoJcmV0c3ViCgovLyBhcmM1NV90cmFuc2FjdGlvbih1aW50NjQsdWludDgpYnl0ZVtdCmFiaV9yb3V0ZV9hcmM1NV90cmFuc2FjdGlvbjoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gdHJhbnNhY3Rpb25JbmRleDogdWludDgKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnQgMQoJPT0KCWFzc2VydAoJYnRvaQoKCS8vIHRyYW5zYWN0aW9uR3JvdXA6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgYXJjNTVfdHJhbnNhY3Rpb24odWludDY0LHVpbnQ4KWJ5dGVbXQoJY2FsbHN1YiBhcmM1NV90cmFuc2FjdGlvbgoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBhcmM1NV90cmFuc2FjdGlvbih0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQsIHRyYW5zYWN0aW9uSW5kZXg6IHVpbnQ4KTogYnl0ZXMKLy8KLy8gUmV0cmlldmUgYSB0cmFuc2FjdGlvbiBmcm9tIGEgZ2l2ZW4gdHJhbnNhY3Rpb24gZ3JvdXAKLy8gQHBhcmFtIHRyYW5zYWN0aW9uR3JvdXAgVHJhbnNhY3Rpb24gR3JvdXAgbm9uY2UKLy8gQHBhcmFtIHRyYW5zYWN0aW9uSW5kZXggSW5kZXggb2YgdHJhbnNhY3Rpb24gd2l0aGluIGdyb3VwCi8vIEByZXR1cm5zIEEgc2luZ2xlIHRyYW5zYWN0aW9uIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggZm9yIHRoZSB0cmFuc2FjdGlvbiBncm91cCBub25jZQphcmM1NV90cmFuc2FjdGlvbjoKCXByb3RvIDIgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoxMTkKCS8vIHRyYW5zYWN0aW9uQm94OiBUcmFuc2FjdGlvbkdyb3VwID0gewoJLy8gICAgICAgICAgICAgbm9uY2U6IHRyYW5zYWN0aW9uR3JvdXAsCgkvLyAgICAgICAgICAgICBpbmRleDogdHJhbnNhY3Rpb25JbmRleAoJLy8gICAgICAgICB9CglmcmFtZV9kaWcgLTEgLy8gdHJhbnNhY3Rpb25Hcm91cDogdWludDY0CglpdG9iCglmcmFtZV9kaWcgLTIgLy8gdHJhbnNhY3Rpb25JbmRleDogdWludDgKCWl0b2IKCWV4dHJhY3QgNyAxCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyB0cmFuc2FjdGlvbkJveDogVHJhbnNhY3Rpb25Hcm91cAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTI0CgkvLyByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uQm94KS52YWx1ZTsKCWZyYW1lX2RpZyAwIC8vIHRyYW5zYWN0aW9uQm94OiBUcmFuc2FjdGlvbkdyb3VwCglib3hfZ2V0Cglhc3NlcnQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gYXJjNTVfc2lnbmF0dXJlcyh1aW50NjQsYWRkcmVzcylieXRlWzY0XVtdCmFiaV9yb3V0ZV9hcmM1NV9zaWduYXR1cmVzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBzaWduZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyB0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGFyYzU1X3NpZ25hdHVyZXModWludDY0LGFkZHJlc3MpYnl0ZVs2NF1bXQoJY2FsbHN1YiBhcmM1NV9zaWduYXR1cmVzCglkdXAKCWxlbgoJaW50IDY0CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYXJjNTVfc2lnbmF0dXJlcyh0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQsIHNpZ25lcjogQWRkcmVzcyk6IGJ5dGVzNjRbXQovLwovLyBSZXRyaWV2ZSBhIGxpc3Qgb2Ygc2lnbmF0dXJlcyBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvbiBncm91cCBub25jZSBhbmQgYWRkcmVzcwovLyBAcGFyYW0gdHJhbnNhY3Rpb25Hcm91cCBUcmFuc2FjdGlvbiBHcm91cCBub25jZQovLyBAcGFyYW0gc2lnbmVyIEFkZHJlc3MgeW91IHdhbnQgdG8gcmV0cmlldmUgc2lnbmF0dXJlcyBmb3IKLy8gQHJldHVybnMgQXJyYXkgb2Ygc2lnbmF0dXJlcwphcmM1NV9zaWduYXR1cmVzOgoJcHJvdG8gMiAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjEzNQoJLy8gc2lnbmF0dXJlQm94OiBUcmFuc2FjdGlvblNpZ25hdHVyZXMgPSB7CgkvLyAgICAgICAgICAgICBub25jZTogdHJhbnNhY3Rpb25Hcm91cCwKCS8vICAgICAgICAgICAgIGFkZHJlc3M6IHNpZ25lcgoJLy8gICAgICAgICB9CglmcmFtZV9kaWcgLTEgLy8gdHJhbnNhY3Rpb25Hcm91cDogdWludDY0CglpdG9iCglmcmFtZV9kaWcgLTIgLy8gc2lnbmVyOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBzaWduYXR1cmVCb3g6IFRyYW5zYWN0aW9uU2lnbmF0dXJlcwoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTQwCgkvLyByZXR1cm4gdGhpcy5fc2lnbmF0dXJlcyhzaWduYXR1cmVCb3gpLnZhbHVlOwoJZnJhbWVfZGlnIDAgLy8gc2lnbmF0dXJlQm94OiBUcmFuc2FjdGlvblNpZ25hdHVyZXMKCWludCAyCglpbnQgMAoJYm94X2V4dHJhY3QKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gYXJjNTVfc2lnbmVyQnlJbmRleCh1aW50NjQpYWRkcmVzcwphYmlfcm91dGVfYXJjNTVfc2lnbmVyQnlJbmRleDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gaW5kZXg6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgYXJjNTVfc2lnbmVyQnlJbmRleCh1aW50NjQpYWRkcmVzcwoJY2FsbHN1YiBhcmM1NV9zaWduZXJCeUluZGV4Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYXJjNTVfc2lnbmVyQnlJbmRleChpbmRleDogdWludDY0KTogQWRkcmVzcwovLwovLyBGaW5kIG91dCB3aGljaCBhZGRyZXNzIGlzIGF0IHRoaXMgaW5kZXggb2YgdGhlIG11bHRpc2lnbmF0dXJlCi8vIEBwYXJhbSBpbmRleCBBZGRyZXNzIGF0IHRoaXMgaW5kZXggb2YgdGhlIG11bHRpc2lnbmF0dXJlCi8vIEByZXR1cm5zIEFkZHJlc3MgYXQgaW5kZXgKYXJjNTVfc2lnbmVyQnlJbmRleDoKCXByb3RvIDEgMQoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTUwCgkvLyByZXR1cm4gdGhpcy5faW5kZXhUb0FkZHJlc3MoaW5kZXgpLnZhbHVlOwoJZnJhbWVfZGlnIC0xIC8vIGluZGV4OiB1aW50NjQKCWl0b2IKCWFwcF9nbG9iYWxfZ2V0CglyZXRzdWIKCi8vIGFyYzU1X2lzU2lnbmVyKGFkZHJlc3MpYm9vbAphYmlfcm91dGVfYXJjNTVfaXNTaWduZXI6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGFkZHJlc3M6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGFyYzU1X2lzU2lnbmVyKGFkZHJlc3MpYm9vbAoJY2FsbHN1YiBhcmM1NV9pc1NpZ25lcgoJYnl0ZSAweDAwCglpbnQgMAoJdW5jb3ZlciAyCglzZXRiaXQKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBhcmM1NV9pc1NpZ25lcihhZGRyZXNzOiBBZGRyZXNzKTogYm9vbGVhbgovLwovLyBDaGVjayBpZiBhbiBhZGRyZXNzIGlzIGEgbWVtYmVyIG9mIHRoZSBtdWx0aXNpZ25hdHVyZQovLyBAcGFyYW0gYWRkcmVzcyBBZGRyZXNzIHRvIGNoZWNrIGlzIGEgc2lnbmVyCi8vIEByZXR1cm5zIFRydWUgaWYgYWRkcmVzcyBpcyBhIHNpZ25lcgphcmM1NV9pc1NpZ25lcjoKCXByb3RvIDEgMQoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTYwCgkvLyByZXR1cm4gdGhpcy5fYWRkcmVzc0NvdW50KGFkZHJlc3MpLnZhbHVlICE9PSAwOwoJZnJhbWVfZGlnIC0xIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMAoJIT0KCXJldHN1YgoKLy8gYXJjNTVfbWJyU2lnSW5jcmVhc2UodWludDY0KXVpbnQ2NAphYmlfcm91dGVfYXJjNTVfbWJyU2lnSW5jcmVhc2U6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIHNpZ25hdHVyZXNTaXplOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGFyYzU1X21iclNpZ0luY3JlYXNlKHVpbnQ2NCl1aW50NjQKCWNhbGxzdWIgYXJjNTVfbWJyU2lnSW5jcmVhc2UKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBhcmM1NV9tYnJTaWdJbmNyZWFzZShzaWduYXR1cmVzU2l6ZTogdWludDY0KTogdWludDY0Ci8vCi8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBiYWxhbmNlIHJlcXVpcmVtZW50IGZvciBzdG9yaW5nIGEgc2lnbmF0dXJlCi8vIEBwYXJhbSBzaWduYXR1cmVzU2l6ZSBTaXplIChpbiBieXRlcykgb2YgdGhlIHNpZ25hdHVyZXMgdG8gc3RvcmUKLy8gQHJldHVybnMgTWluaW11bSBiYWxhbmNlIHJlcXVpcmVtZW50IGluY3JlYXNlCmFyYzU1X21iclNpZ0luY3JlYXNlOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gNAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTcwCgkvLyBjdXJyZW50QmFsYW5jZSA9IHRoaXMuYXBwLmFkZHJlc3MuYmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDAgLy8gY3VycmVudEJhbGFuY2U6IHVpbnQ2NAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTcxCgkvLyBtaW5pbXVtQmFsYW5jZSA9IHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDEgLy8gbWluaW11bUJhbGFuY2U6IHVpbnQ2NAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTc2CgkvLyBtYnJTaWdSZXF1aXJlZCA9ICgyNTAwKSArICg0MDAgKiAoNDAgKyAyICsgc2lnbmF0dXJlc1NpemUpKQoJaW50IDI1MDAKCWludCA0MDAKCWludCA0MgoJZnJhbWVfZGlnIC0xIC8vIHNpZ25hdHVyZXNTaXplOiB1aW50NjQKCSsKCSoKCSsKCWZyYW1lX2J1cnkgMiAvLyBtYnJTaWdSZXF1aXJlZDogdWludDY0CgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoxNzgKCS8vIG5ld01pbmltdW1CYWxhbmNlID0gbWluaW11bUJhbGFuY2UgKyBtYnJTaWdSZXF1aXJlZAoJZnJhbWVfZGlnIDEgLy8gbWluaW11bUJhbGFuY2U6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gbWJyU2lnUmVxdWlyZWQ6IHVpbnQ2NAoJKwoJZnJhbWVfYnVyeSAzIC8vIG5ld01pbmltdW1CYWxhbmNlOiB1aW50NjQKCgkvLyBpZjBfY29uZGl0aW9uCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjE3OQoJLy8gY3VycmVudEJhbGFuY2UgPj0gbmV3TWluaW11bUJhbGFuY2UKCWZyYW1lX2RpZyAwIC8vIGN1cnJlbnRCYWxhbmNlOiB1aW50NjQKCWZyYW1lX2RpZyAzIC8vIG5ld01pbmltdW1CYWxhbmNlOiB1aW50NjQKCT49CglieiBpZjBfZW5kCgoJLy8gaWYwX2NvbnNlcXVlbnQKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTgwCgkvLyByZXR1cm4gMDsKCWludCAwCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMwoJcmV0c3ViCgppZjBfZW5kOgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoxODMKCS8vIHJldHVybiBuZXdNaW5pbXVtQmFsYW5jZSAtIGN1cnJlbnRCYWxhbmNlOwoJZnJhbWVfZGlnIDMgLy8gbmV3TWluaW11bUJhbGFuY2U6IHVpbnQ2NAoJZnJhbWVfZGlnIDAgLy8gY3VycmVudEJhbGFuY2U6IHVpbnQ2NAoJLQoKCS8vIHNldCB0aGUgc3Vicm91dGluZSByZXR1cm4gdmFsdWUKCWZyYW1lX2J1cnkgMAoKCS8vIHBvcCBhbGwgbG9jYWwgdmFyaWFibGVzIGZyb20gdGhlIHN0YWNrCglwb3BuIDMKCXJldHN1YgoKLy8gYXJjNTVfbWJyVHhuSW5jcmVhc2UodWludDY0KXVpbnQ2NAphYmlfcm91dGVfYXJjNTVfbWJyVHhuSW5jcmVhc2U6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIHRyYW5zYWN0aW9uU2l6ZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBhcmM1NV9tYnJUeG5JbmNyZWFzZSh1aW50NjQpdWludDY0CgljYWxsc3ViIGFyYzU1X21iclR4bkluY3JlYXNlCglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gYXJjNTVfbWJyVHhuSW5jcmVhc2UodHJhbnNhY3Rpb25TaXplOiB1aW50NjQpOiB1aW50NjQKLy8KLy8gQ2FsY3VsYXRlIHRoZSBtaW5pbXVtIGJhbGFuY2UgcmVxdWlyZW1lbnQgZm9yIHN0b3JpbmcgYSB0cmFuc2FjdGlvbgovLyBAcGFyYW0gdHJhbnNhY3Rpb25TaXplIFNpemUgKGluIGJ5dGVzKSBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gc3RvcmUKLy8gQHJldHVybnMgTWluaW11bSBiYWxhbmNlIHJlcXVpcmVtZW50IGluY3JlYXNlCmFyYzU1X21iclR4bkluY3JlYXNlOgoJcHJvdG8gMSAxCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gNAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTkzCgkvLyBjdXJyZW50QmFsYW5jZSA9IHRoaXMuYXBwLmFkZHJlc3MuYmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDAgLy8gY3VycmVudEJhbGFuY2U6IHVpbnQ2NAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTk0CgkvLyBtaW5pbXVtQmFsYW5jZSA9IHRoaXMuYXBwLmFkZHJlc3MubWluQmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDEgLy8gbWluaW11bUJhbGFuY2U6IHVpbnQ2NAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MTk5CgkvLyBtYnJUeG5SZXF1aXJlZCA9ICgyNTAwKSArICg0MDAgKiAoOSArIHRyYW5zYWN0aW9uU2l6ZSkpCglpbnQgMjUwMAoJaW50IDQwMAoJaW50IDkKCWZyYW1lX2RpZyAtMSAvLyB0cmFuc2FjdGlvblNpemU6IHVpbnQ2NAoJKwoJKgoJKwoJZnJhbWVfYnVyeSAyIC8vIG1iclR4blJlcXVpcmVkOiB1aW50NjQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjIwMQoJLy8gbmV3TWluaW11bUJhbGFuY2UgPSBtaW5pbXVtQmFsYW5jZSArIG1iclR4blJlcXVpcmVkCglmcmFtZV9kaWcgMSAvLyBtaW5pbXVtQmFsYW5jZTogdWludDY0CglmcmFtZV9kaWcgMiAvLyBtYnJUeG5SZXF1aXJlZDogdWludDY0CgkrCglmcmFtZV9idXJ5IDMgLy8gbmV3TWluaW11bUJhbGFuY2U6IHVpbnQ2NAoKCS8vIGlmMV9jb25kaXRpb24KCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MjAyCgkvLyBjdXJyZW50QmFsYW5jZSA+PSBuZXdNaW5pbXVtQmFsYW5jZQoJZnJhbWVfZGlnIDAgLy8gY3VycmVudEJhbGFuY2U6IHVpbnQ2NAoJZnJhbWVfZGlnIDMgLy8gbmV3TWluaW11bUJhbGFuY2U6IHVpbnQ2NAoJPj0KCWJ6IGlmMV9lbmQKCgkvLyBpZjFfY29uc2VxdWVudAoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyMDMKCS8vIHJldHVybiAwOwoJaW50IDAKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCgkvLyBwb3AgYWxsIGxvY2FsIHZhcmlhYmxlcyBmcm9tIHRoZSBzdGFjawoJcG9wbiAzCglyZXRzdWIKCmlmMV9lbmQ6CgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjIwNgoJLy8gcmV0dXJuIG5ld01pbmltdW1CYWxhbmNlIC0gY3VycmVudEJhbGFuY2U7CglmcmFtZV9kaWcgMyAvLyBuZXdNaW5pbXVtQmFsYW5jZTogdWludDY0CglmcmFtZV9kaWcgMCAvLyBjdXJyZW50QmFsYW5jZTogdWludDY0CgktCgoJLy8gc2V0IHRoZSBzdWJyb3V0aW5lIHJldHVybiB2YWx1ZQoJZnJhbWVfYnVyeSAwCgoJLy8gcG9wIGFsbCBsb2NhbCB2YXJpYWJsZXMgZnJvbSB0aGUgc3RhY2sKCXBvcG4gMwoJcmV0c3ViCgovLyBhcmM1NV9zZXR1cCh1aW50OCxhZGRyZXNzW10pdm9pZAphYmlfcm91dGVfYXJjNTVfc2V0dXA6CgkvLyBhZGRyZXNzZXM6IGFkZHJlc3NbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyB0aHJlc2hvbGQ6IHVpbnQ4Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDEKCT09Cglhc3NlcnQKCWJ0b2kKCgkvLyBleGVjdXRlIGFyYzU1X3NldHVwKHVpbnQ4LGFkZHJlc3NbXSl2b2lkCgljYWxsc3ViIGFyYzU1X3NldHVwCglpbnQgMQoJcmV0dXJuCgovLyBhcmM1NV9zZXR1cCh0aHJlc2hvbGQ6IHVpbnQ4LCBhZGRyZXNzZXM6IEFkZHJlc3NbXSk6IHZvaWQKLy8KLy8gU2V0dXAgT24tQ2hhaW4gTXNpZyBBcHAuIFRoaXMgY2FuIG9ubHkgYmUgY2FsbGVkIHdoaWxzdCBubyB0cmFuc2FjdGlvbiBncm91cHMgaGF2ZSBiZWVuIGNyZWF0ZWQuCi8vIEBwYXJhbSB0aHJlc2hvbGQgSW5pdGlhbCBtdWx0aXNpZyB0aHJlc2hvbGQsIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAKLy8gQHBhcmFtIGFkZHJlc3NlcyBBcnJheSBvZiBhZGRyZXNzZXMgdGhhdCBtYWtlIHVwIHRoZSBtdWx0aXNpZwphcmM1NV9zZXR1cDoKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXBuIDUKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjIyMAoJLy8gYXNzZXJ0KCF0aGlzLl9ub25jZS52YWx1ZSkKCWJ5dGUgMHg1ZjZlNmY2ZTYzNjUgLy8gIl9ub25jZSIKCWFwcF9nbG9iYWxfZ2V0CgkhCglhc3NlcnQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjIyMQoJLy8gdGhpcy5vbmx5Q3JlYXRvcigpCgljYWxsc3ViIG9ubHlDcmVhdG9yCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyMjMKCS8vIHQ6IHVpbnQ2NCA9IGJ0b2kocmF3Qnl0ZXModGhyZXNob2xkKSkKCWZyYW1lX2RpZyAtMSAvLyB0aHJlc2hvbGQ6IHVpbnQ4CglpdG9iCglleHRyYWN0IDcgMQoJYnRvaQoJZnJhbWVfYnVyeSAwIC8vIHQ6IHVpbnQ2NAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MjI0CgkvLyBhc3NlcnQodCkKCWZyYW1lX2RpZyAwIC8vIHQ6IHVpbnQ2NAoJYXNzZXJ0CgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyMjUKCS8vIHRoaXMuX3RocmVzaG9sZC52YWx1ZSA9IHQKCWJ5dGUgMHg1Zjc0Njg3MjY1NzM2ODZmNmM2NCAvLyAiX3RocmVzaG9sZCIKCWZyYW1lX2RpZyAwIC8vIHQ6IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjIyNwoJLy8gdGhpcy5fbm9uY2UudmFsdWUgPSAwCglieXRlIDB4NWY2ZTZmNmU2MzY1IC8vICJfbm9uY2UiCglpbnQgMAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjIzMQoJLy8gcEluZGV4ID0gMAoJaW50IDAKCWZyYW1lX2J1cnkgMSAvLyBwSW5kZXg6IHVpbnQ2NAoKd2hpbGVfMDoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MjMyCgkvLyB0aGlzLl9pbmRleFRvQWRkcmVzcyhwSW5kZXgpLmV4aXN0cwoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJZnJhbWVfZGlnIDEgLy8gcEluZGV4OiB1aW50NjQKCWl0b2IKCWFwcF9nbG9iYWxfZ2V0X2V4Cglzd2FwCglwb3AKCWJ6IHdoaWxlXzBfZW5kCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyMzMKCS8vIGFkZHJlc3MgPSB0aGlzLl9pbmRleFRvQWRkcmVzcyhwSW5kZXgpLnZhbHVlCglmcmFtZV9kaWcgMSAvLyBwSW5kZXg6IHVpbnQ2NAoJaXRvYgoJYXBwX2dsb2JhbF9nZXQKCWZyYW1lX2J1cnkgMiAvLyBhZGRyZXNzOiBhZGRyZXNzCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyMzcKCS8vIHRoaXMuX2FkZHJlc3NDb3VudChhZGRyZXNzKS5kZWxldGUKCWZyYW1lX2RpZyAyIC8vIGFkZHJlc3M6IGFkZHJlc3MKCWFwcF9nbG9iYWxfZGVsCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyMzgKCS8vIHRoaXMuX2luZGV4VG9BZGRyZXNzKHBJbmRleCkuZGVsZXRlCglmcmFtZV9kaWcgMSAvLyBwSW5kZXg6IHVpbnQ2NAoJaXRvYgoJYXBwX2dsb2JhbF9kZWwKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjIzOQoJLy8gcEluZGV4ICs9IDEKCWZyYW1lX2RpZyAxIC8vIHBJbmRleDogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSAxIC8vIHBJbmRleDogdWludDY0CgliIHdoaWxlXzAKCndoaWxlXzBfZW5kOgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyNDMKCS8vIG5JbmRleCA9IDAKCWludCAwCglmcmFtZV9idXJ5IDMgLy8gbkluZGV4OiB1aW50NjQKCndoaWxlXzE6CgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjI0NQoJLy8gbkluZGV4IDwgYWRkcmVzc2VzLmxlbmd0aAoJZnJhbWVfZGlnIDMgLy8gbkluZGV4OiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzZXM6IEFkZHJlc3NbXQoJbGVuCglpbnQgMzIKCS8KCTwKCWJ6IHdoaWxlXzFfZW5kCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyNDYKCS8vIGFkZHJlc3MgPSBhZGRyZXNzZXNbbkluZGV4XQoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3NlczogQWRkcmVzc1tdCglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50IDAgLy8gaW5pdGlhbCBvZmZzZXQKCWZyYW1lX2RpZyAzIC8vIG5JbmRleDogdWludDY0CglpbnQgMzIKCSogLy8gYWNjICogdHlwZUxlbmd0aAoJKwoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJaW50IDMyCglleHRyYWN0MwoJZnJhbWVfYnVyeSA0IC8vIGFkZHJlc3M6IEFkZHJlc3MKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjI0OQoJLy8gdGhpcy5faW5kZXhUb0FkZHJlc3MobkluZGV4KS52YWx1ZSA9IGFkZHJlc3MKCWZyYW1lX2RpZyAzIC8vIG5JbmRleDogdWludDY0CglpdG9iCglmcmFtZV9kaWcgNCAvLyBhZGRyZXNzOiBBZGRyZXNzCglhcHBfZ2xvYmFsX3B1dAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MjUzCgkvLyB0aGlzLl9hZGRyZXNzQ291bnQoYWRkcmVzcykudmFsdWUgKz0gMQoJZnJhbWVfZGlnIDQgLy8gYWRkcmVzczogQWRkcmVzcwoJYXBwX2dsb2JhbF9nZXQKCWludCAxCgkrCglmcmFtZV9kaWcgNCAvLyBhZGRyZXNzOiBBZGRyZXNzCglzd2FwCglhcHBfZ2xvYmFsX3B1dAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MjU1CgkvLyBuSW5kZXggKz0gMQoJZnJhbWVfZGlnIDMgLy8gbkluZGV4OiB1aW50NjQKCWludCAxCgkrCglmcmFtZV9idXJ5IDMgLy8gbkluZGV4OiB1aW50NjQKCWIgd2hpbGVfMQoKd2hpbGVfMV9lbmQ6CglyZXRzdWIKCi8vIGFyYzU1X25ld1RyYW5zYWN0aW9uR3JvdXAoKXVpbnQ2NAphYmlfcm91dGVfYXJjNTVfbmV3VHJhbnNhY3Rpb25Hcm91cDoKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBhcmM1NV9uZXdUcmFuc2FjdGlvbkdyb3VwKCl1aW50NjQKCWNhbGxzdWIgYXJjNTVfbmV3VHJhbnNhY3Rpb25Hcm91cAoJaXRvYgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGFyYzU1X25ld1RyYW5zYWN0aW9uR3JvdXAoKTogdWludDY0Ci8vCi8vIEdlbmVyYXRlIGEgbmV3IHRyYW5zYWN0aW9uIGdyb3VwIG5vbmNlIGZvciBob2xkaW5nIHBlbmRpbmcgdHJhbnNhY3Rpb25zCi8vIEByZXR1cm5zIHRyYW5zYWN0aW9uR3JvdXAgVHJhbnNhY3Rpb24gR3JvdXAgbm9uY2UKYXJjNTVfbmV3VHJhbnNhY3Rpb25Hcm91cDoKCXByb3RvIDAgMQoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyNjQKCS8vIHRoaXMub25seVNpZ25lcigpCgljYWxsc3ViIG9ubHlTaWduZXIKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjI2NgoJLy8gbiA9IHRoaXMuYXJjNTVfbmV4dFRyYW5zYWN0aW9uR3JvdXAoKQoJY2FsbHN1YiBhcmM1NV9uZXh0VHJhbnNhY3Rpb25Hcm91cAoJZnJhbWVfYnVyeSAwIC8vIG46IHVpbnQ2NAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MjY3CgkvLyB0aGlzLl9ub25jZS52YWx1ZSA9IG4KCWJ5dGUgMHg1ZjZlNmY2ZTYzNjUgLy8gIl9ub25jZSIKCWZyYW1lX2RpZyAwIC8vIG46IHVpbnQ2NAoJYXBwX2dsb2JhbF9wdXQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjI2OQoJLy8gcmV0dXJuIG47CglmcmFtZV9kaWcgMCAvLyBuOiB1aW50NjQKCgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gYXJjNTVfYWRkVHJhbnNhY3Rpb24ocGF5LHVpbnQ2NCx1aW50OCxieXRlW10pdm9pZAphYmlfcm91dGVfYXJjNTVfYWRkVHJhbnNhY3Rpb246CgkvLyB0cmFuc2FjdGlvbjogYnl0ZVtdCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglleHRyYWN0IDIgMAoKCS8vIGluZGV4OiB1aW50OAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAxCgk9PQoJYXNzZXJ0CglidG9pCgoJLy8gdHJhbnNhY3Rpb25Hcm91cDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gY29zdHM6IHBheQoJdHhuIEdyb3VwSW5kZXgKCWludCAxCgktCglkdXAKCWd0eG5zIFR5cGVFbnVtCglpbnQgcGF5Cgk9PQoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBhcmM1NV9hZGRUcmFuc2FjdGlvbihwYXksdWludDY0LHVpbnQ4LGJ5dGVbXSl2b2lkCgljYWxsc3ViIGFyYzU1X2FkZFRyYW5zYWN0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBhcmM1NV9hZGRUcmFuc2FjdGlvbihjb3N0czogUGF5VHhuLCB0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQsIGluZGV4OiB1aW50OCwgdHJhbnNhY3Rpb246IGJ5dGVzKTogdm9pZAovLwovLyBBZGQgYSB0cmFuc2FjdGlvbiB0byBhbiBleGlzdGluZyBncm91cC4gT25seSBvbmUgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIGluY2x1ZGVkIHBlciBjYWxsCi8vIEBwYXJhbSBjb3N0cyBNaW5pbXVtIEJhbGFuY2UgUmVxdWlyZW1lbnQgZm9yIGFzc29jaWF0ZWQgYm94IHN0b3JhZ2UgY29zdHM6ICgyNTAwKSArICg0MDAgKiAoOSArIHRyYW5zYWN0aW9uLmxlbmd0aCkpCi8vIEBwYXJhbSB0cmFuc2FjdGlvbkdyb3VwIFRyYW5zYWN0aW9uIEdyb3VwIG5vbmNlCi8vIEBwYXJhbSBpbmRleCBUcmFuc2FjdGlvbiBwb3NpdGlvbiB3aXRoaW4gYXRvbWljIGdyb3VwIHRvIGFkZAovLyBAcGFyYW0gdHJhbnNhY3Rpb24gVHJhbnNhY3Rpb24gdG8gYWRkCmFyYzU1X2FkZFRyYW5zYWN0aW9uOgoJcHJvdG8gNCAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gNAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6Mjg1CgkvLyB0aGlzLm9ubHlTaWduZXIoKQoJY2FsbHN1YiBvbmx5U2lnbmVyCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyODcKCS8vIGFzc2VydCh0cmFuc2FjdGlvbkdyb3VwKQoJZnJhbWVfZGlnIC0yIC8vIHRyYW5zYWN0aW9uR3JvdXA6IHVpbnQ2NAoJYXNzZXJ0CgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyODgKCS8vIGFzc2VydCh0cmFuc2FjdGlvbkdyb3VwIDw9IHRoaXMuX25vbmNlLnZhbHVlKQoJZnJhbWVfZGlnIC0yIC8vIHRyYW5zYWN0aW9uR3JvdXA6IHVpbnQ2NAoJYnl0ZSAweDVmNmU2ZjZlNjM2NSAvLyAiX25vbmNlIgoJYXBwX2dsb2JhbF9nZXQKCTw9Cglhc3NlcnQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjI5MAoJLy8gdHJhbnNhY3Rpb25Cb3g6IFRyYW5zYWN0aW9uR3JvdXAgPSB7CgkvLyAgICAgICAgICAgICBub25jZTogdHJhbnNhY3Rpb25Hcm91cCwKCS8vICAgICAgICAgICAgIGluZGV4OiBpbmRleCwKCS8vICAgICAgICAgfQoJZnJhbWVfZGlnIC0yIC8vIHRyYW5zYWN0aW9uR3JvdXA6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIC0zIC8vIGluZGV4OiB1aW50OAoJaXRvYgoJZXh0cmFjdCA3IDEKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHRyYW5zYWN0aW9uQm94OiBUcmFuc2FjdGlvbkdyb3VwCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czoyOTcKCS8vIHRyYW5zYWN0aW9uRGF0YSA9IHRyYW5zYWN0aW9uCglmcmFtZV9kaWcgLTQgLy8gdHJhbnNhY3Rpb246IGJ5dGVzCglmcmFtZV9idXJ5IDEgLy8gdHJhbnNhY3Rpb25EYXRhOiBieXRlW10KCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjI5OAoJLy8gZ3JvdXBQb3NpdGlvbiA9IHRoaXMudHhuLmdyb3VwSW5kZXggKyAxCgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBncm91cFBvc2l0aW9uOiB1aW50NjQKCgkvLyBpZjJfY29uZGl0aW9uCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjI5OQoJLy8gZ3JvdXBQb3NpdGlvbiA8IGdsb2JhbHMuZ3JvdXBTaXplCglmcmFtZV9kaWcgMiAvLyBncm91cFBvc2l0aW9uOiB1aW50NjQKCWdsb2JhbCBHcm91cFNpemUKCTwKCWJ6IGlmMl9lbmQKCi8vIGlmMl9jb25zZXF1ZW50CmRvX3doaWxlXzA6CgkvLyBpZjNfY29uZGl0aW9uCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjMwMgoJLy8gdGhpcy50eG5Hcm91cFtncm91cFBvc2l0aW9uXS5hcHBsaWNhdGlvbklEID09PSB0aGlzLnR4bi5hcHBsaWNhdGlvbklECgkvLyAgICAgICAgICAgICAgICAgICAgICYmIHRoaXMudHhuR3JvdXBbZ3JvdXBQb3NpdGlvbl0uYXBwbGljYXRpb25BcmdzWzBdID09PSBtZXRob2QoImFyYzU1X2FkZFRyYW5zYWN0aW9uQ29udGludWVkKGJ5dGVbXSl2b2lkIikKCWZyYW1lX2RpZyAyIC8vIGdyb3VwUG9zaXRpb246IHVpbnQ2NAoJZ3R4bnMgQXBwbGljYXRpb25JRAoJdHhuIEFwcGxpY2F0aW9uSUQKCT09CglkdXAKCWJ6IHNraXBfYW5kMAoJZnJhbWVfZGlnIDIgLy8gZ3JvdXBQb3NpdGlvbjogdWludDY0CglndHhucyBBcHBsaWNhdGlvbkFyZ3MgMAoJbWV0aG9kICJhcmM1NV9hZGRUcmFuc2FjdGlvbkNvbnRpbnVlZChieXRlW10pdm9pZCIKCT09CgkmJgoKc2tpcF9hbmQwOgoJYnogaWYzX2VuZAoKCS8vIGlmM19jb25zZXF1ZW50CgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjMwNQoJLy8gdHJhbnNhY3Rpb25EYXRhICs9IGV4dHJhY3QzKHRoaXMudHhuR3JvdXBbZ3JvdXBQb3NpdGlvbl0uYXBwbGljYXRpb25BcmdzWzFdLCAyLCAwKQoJZnJhbWVfZGlnIDEgLy8gdHJhbnNhY3Rpb25EYXRhOiBieXRlW10KCWZyYW1lX2RpZyAyIC8vIGdyb3VwUG9zaXRpb246IHVpbnQ2NAoJZ3R4bnMgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgljb25jYXQKCWZyYW1lX2J1cnkgMSAvLyB0cmFuc2FjdGlvbkRhdGE6IGJ5dGVbXQoKaWYzX2VuZDoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MzA3CgkvLyBncm91cFBvc2l0aW9uICs9IDEKCWZyYW1lX2RpZyAyIC8vIGdyb3VwUG9zaXRpb246IHVpbnQ2NAoJaW50IDEKCSsKCWZyYW1lX2J1cnkgMiAvLyBncm91cFBvc2l0aW9uOiB1aW50NjQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjMwOAoJLy8gZ3JvdXBQb3NpdGlvbiA8IGdsb2JhbHMuZ3JvdXBTaXplCglmcmFtZV9kaWcgMiAvLyBncm91cFBvc2l0aW9uOiB1aW50NjQKCWdsb2JhbCBHcm91cFNpemUKCTwKCWJueiBkb193aGlsZV8wCgppZjJfZW5kOgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czozMTEKCS8vIG1iclR4bkluY3JlYXNlID0gdGhpcy5hcmM1NV9tYnJUeG5JbmNyZWFzZSh0cmFuc2FjdGlvbkRhdGEubGVuZ3RoKQoJZnJhbWVfZGlnIDEgLy8gdHJhbnNhY3Rpb25EYXRhOiBieXRlW10KCWxlbgoJY2FsbHN1YiBhcmM1NV9tYnJUeG5JbmNyZWFzZQoJZnJhbWVfYnVyeSAzIC8vIG1iclR4bkluY3JlYXNlOiB1aW50NjQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjMxMwoJLy8gdmVyaWZ5UGF5VHhuKGNvc3RzLCB7CgkvLyAgICAgICAgICAgICByZWNlaXZlcjogdGhpcy5hcHAuYWRkcmVzcywKCS8vICAgICAgICAgICAgIGFtb3VudDogeyBncmVhdGVyVGhhbkVxdWFsVG86IG1iclR4bkluY3JlYXNlIH0KCS8vICAgICAgICAgfSkKCS8vIHZlcmlmeSByZWNlaXZlcgoJZnJhbWVfZGlnIC0xIC8vIGNvc3RzOiBQYXlUeG4KCWd0eG5zIFJlY2VpdmVyCglnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIHZlcmlmeSBhbW91bnQKCWZyYW1lX2RpZyAtMSAvLyBjb3N0czogUGF5VHhuCglndHhucyBBbW91bnQKCWZyYW1lX2RpZyAzIC8vIG1iclR4bkluY3JlYXNlOiB1aW50NjQKCT49Cglhc3NlcnQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjMxOQoJLy8gdGhpcy5fdHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uQm94KS52YWx1ZSA9IHRyYW5zYWN0aW9uRGF0YQoJZnJhbWVfZGlnIDAgLy8gdHJhbnNhY3Rpb25Cb3g6IFRyYW5zYWN0aW9uR3JvdXAKCWR1cAoJYm94X2RlbAoJcG9wCglmcmFtZV9kaWcgMSAvLyB0cmFuc2FjdGlvbkRhdGE6IGJ5dGVbXQoJYm94X3B1dAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MzIyCgkvLyB0aGlzLlRyYW5zYWN0aW9uQWRkZWQubG9nKHsKCS8vICAgICAgICAgICAgIHRyYW5zYWN0aW9uR3JvdXA6IHRyYW5zYWN0aW9uR3JvdXAsCgkvLyAgICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBpbmRleAoJLy8gICAgICAgICB9KQoJYnl0ZSAweDE4NDlhNTk0IC8vIFRyYW5zYWN0aW9uQWRkZWQodWludDY0LHVpbnQ4KQoJZnJhbWVfZGlnIC0yIC8vIHRyYW5zYWN0aW9uR3JvdXA6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIC0zIC8vIGluZGV4OiB1aW50OAoJaXRvYgoJZXh0cmFjdCA3IDEKCWNvbmNhdAoJY29uY2F0Cglsb2cKCXJldHN1YgoKLy8gYXJjNTVfYWRkVHJhbnNhY3Rpb25Db250aW51ZWQoYnl0ZVtdKXZvaWQKYWJpX3JvdXRlX2FyYzU1X2FkZFRyYW5zYWN0aW9uQ29udGludWVkOgoJLy8gdHJhbnNhY3Rpb246IGJ5dGVbXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZXh0cmFjdCAyIDAKCgkvLyBleGVjdXRlIGFyYzU1X2FkZFRyYW5zYWN0aW9uQ29udGludWVkKGJ5dGVbXSl2b2lkCgljYWxsc3ViIGFyYzU1X2FkZFRyYW5zYWN0aW9uQ29udGludWVkCglpbnQgMQoJcmV0dXJuCgovLyBhcmM1NV9hZGRUcmFuc2FjdGlvbkNvbnRpbnVlZCh0cmFuc2FjdGlvbjogYnl0ZXMpOiB2b2lkCmFyYzU1X2FkZFRyYW5zYWN0aW9uQ29udGludWVkOgoJcHJvdG8gMSAwCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czozMzEKCS8vIHRoaXMub25seVNpZ25lcigpCgljYWxsc3ViIG9ubHlTaWduZXIKCXJldHN1YgoKLy8gYXJjNTVfcmVtb3ZlVHJhbnNhY3Rpb24odWludDY0LHVpbnQ4KXZvaWQKYWJpX3JvdXRlX2FyYzU1X3JlbW92ZVRyYW5zYWN0aW9uOgoJLy8gaW5kZXg6IHVpbnQ4Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDEKCT09Cglhc3NlcnQKCWJ0b2kKCgkvLyB0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGFyYzU1X3JlbW92ZVRyYW5zYWN0aW9uKHVpbnQ2NCx1aW50OCl2b2lkCgljYWxsc3ViIGFyYzU1X3JlbW92ZVRyYW5zYWN0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBhcmM1NV9yZW1vdmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQsIGluZGV4OiB1aW50OCk6IHZvaWQKLy8KLy8gUmVtb3ZlIHRyYW5zYWN0aW9uIGZyb20gdGhlIGFwcC4gVGhlIE1CUiBhc3NvY2lhdGVkIHdpdGggdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlIHRyYW5zYWN0aW9uIHNlbmRlci4KLy8gQHBhcmFtIHRyYW5zYWN0aW9uR3JvdXAgVHJhbnNhY3Rpb24gR3JvdXAgbm9uY2UKLy8gQHBhcmFtIGluZGV4IFRyYW5zYWN0aW9uIHBvc2l0aW9uIHdpdGhpbiBhdG9taWMgZ3JvdXAgdG8gcmVtb3ZlCmFyYzU1X3JlbW92ZVRyYW5zYWN0aW9uOgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cG4gMwoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MzQzCgkvLyB0aGlzLm9ubHlTaWduZXIoKQoJY2FsbHN1YiBvbmx5U2lnbmVyCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czozNDUKCS8vIHRyYW5zYWN0aW9uQm94OiBUcmFuc2FjdGlvbkdyb3VwID0gewoJLy8gICAgICAgICAgICAgbm9uY2U6IHRyYW5zYWN0aW9uR3JvdXAsCgkvLyAgICAgICAgICAgICBpbmRleDogaW5kZXgsCgkvLyAgICAgICAgIH0KCWZyYW1lX2RpZyAtMSAvLyB0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAtMiAvLyBpbmRleDogdWludDgKCWl0b2IKCWV4dHJhY3QgNyAxCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyB0cmFuc2FjdGlvbkJveDogVHJhbnNhY3Rpb25Hcm91cAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MzUwCgkvLyB0eG5MZW5ndGggPSB0aGlzLl90cmFuc2FjdGlvbnModHJhbnNhY3Rpb25Cb3gpLnNpemUKCWZyYW1lX2RpZyAwIC8vIHRyYW5zYWN0aW9uQm94OiBUcmFuc2FjdGlvbkdyb3VwCglib3hfbGVuCglhc3NlcnQKCWZyYW1lX2J1cnkgMSAvLyB0eG5MZW5ndGg6IHVpbnQ2NAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MzUxCgkvLyB0aGlzLl90cmFuc2FjdGlvbnModHJhbnNhY3Rpb25Cb3gpLmRlbGV0ZQoJZnJhbWVfZGlnIDAgLy8gdHJhbnNhY3Rpb25Cb3g6IFRyYW5zYWN0aW9uR3JvdXAKCWJveF9kZWwKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjM1NgoJLy8gbWJyVHhuRGVjcmVhc2UgPSAoMjUwMCkgKyAoNDAwICogKDkgKyB0eG5MZW5ndGgpKQoJaW50IDI1MDAKCWludCA0MDAKCWludCA5CglmcmFtZV9kaWcgMSAvLyB0eG5MZW5ndGg6IHVpbnQ2NAoJKwoJKgoJKwoJZnJhbWVfYnVyeSAyIC8vIG1iclR4bkRlY3JlYXNlOiB1aW50NjQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjM1OAoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgICAgICAgcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlciwKCS8vICAgICAgICAgICAgIGFtb3VudDogbWJyVHhuRGVjcmVhc2UKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjM1OQoJLy8gcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MzYwCgkvLyBhbW91bnQ6IG1iclR4bkRlY3JlYXNlCglmcmFtZV9kaWcgMiAvLyBtYnJUeG5EZWNyZWFzZTogdWludDY0CglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjM2NAoJLy8gdGhpcy5UcmFuc2FjdGlvblJlbW92ZWQubG9nKHsKCS8vICAgICAgICAgICAgIHRyYW5zYWN0aW9uR3JvdXA6IHRyYW5zYWN0aW9uR3JvdXAsCgkvLyAgICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBpbmRleAoJLy8gICAgICAgICB9KQoJYnl0ZSAweDNlOWIyY2E1IC8vIFRyYW5zYWN0aW9uUmVtb3ZlZCh1aW50NjQsdWludDgpCglmcmFtZV9kaWcgLTEgLy8gdHJhbnNhY3Rpb25Hcm91cDogdWludDY0CglpdG9iCglmcmFtZV9kaWcgLTIgLy8gaW5kZXg6IHVpbnQ4CglpdG9iCglleHRyYWN0IDcgMQoJY29uY2F0Cgljb25jYXQKCWxvZwoJcmV0c3ViCgovLyBhcmM1NV9zZXRTaWduYXR1cmVzKHBheSx1aW50NjQsYnl0ZVs2NF1bXSl2b2lkCmFiaV9yb3V0ZV9hcmM1NV9zZXRTaWduYXR1cmVzOgoJLy8gc2lnbmF0dXJlczogYnl0ZVs2NF1bXQoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyB0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBjb3N0czogcGF5Cgl0eG4gR3JvdXBJbmRleAoJaW50IDEKCS0KCWR1cAoJZ3R4bnMgVHlwZUVudW0KCWludCBwYXkKCT09Cglhc3NlcnQKCgkvLyBleGVjdXRlIGFyYzU1X3NldFNpZ25hdHVyZXMocGF5LHVpbnQ2NCxieXRlWzY0XVtdKXZvaWQKCWNhbGxzdWIgYXJjNTVfc2V0U2lnbmF0dXJlcwoJaW50IDEKCXJldHVybgoKLy8gYXJjNTVfc2V0U2lnbmF0dXJlcyhjb3N0czogUGF5VHhuLCB0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQsIHNpZ25hdHVyZXM6IGJ5dGVzNjRbXSk6IHZvaWQKLy8KLy8gU2V0IHNpZ25hdHVyZXMgZm9yIGEgcGFydGljdWxhciB0cmFuc2FjdGlvbiBncm91cC4gU2lnbmF0dXJlcyBtdXN0IGJlIGluY2x1ZGVkIGFzIGFuIGFycmF5IG9mIGJ5dGUtYXJyYXlzCi8vIEBwYXJhbSBjb3N0cyBNaW5pbXVtIEJhbGFuY2UgUmVxdWlyZW1lbnQgZm9yIGFzc29jaWF0ZWQgYm94IHN0b3JhZ2UgY29zdHM6ICgyNTAwKSArICg0MDAgKiAoNDAgKyBzaWduYXR1cmVzLmxlbmd0aCkpCi8vIEBwYXJhbSB0cmFuc2FjdGlvbkdyb3VwIFRyYW5zYWN0aW9uIEdyb3VwIG5vbmNlCi8vIEBwYXJhbSBzaWduYXR1cmVzIEFycmF5IG9mIHNpZ25hdHVyZXMKYXJjNTVfc2V0U2lnbmF0dXJlczoKCXByb3RvIDMgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXAKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjM4MQoJLy8gdGhpcy5vbmx5U2lnbmVyKCkKCWNhbGxzdWIgb25seVNpZ25lcgoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6MzgzCgkvLyBtYnJTaWdJbmNyZWFzZSA9IHRoaXMuYXJjNTVfbWJyU2lnSW5jcmVhc2Uoc2lnbmF0dXJlcy5sZW5ndGggKiA2NCkKCWZyYW1lX2RpZyAtMyAvLyBzaWduYXR1cmVzOiBieXRlczY0W10KCWxlbgoJaW50IDY0CgkvCglpbnQgNjQKCSoKCWNhbGxzdWIgYXJjNTVfbWJyU2lnSW5jcmVhc2UKCWZyYW1lX2J1cnkgMCAvLyBtYnJTaWdJbmNyZWFzZTogdWludDY0CgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czozODUKCS8vIHZlcmlmeVBheVR4bihjb3N0cywgewoJLy8gICAgICAgICAgICAgcmVjZWl2ZXI6IHRoaXMuYXBwLmFkZHJlc3MsCgkvLyAgICAgICAgICAgICBhbW91bnQ6IHsgZ3JlYXRlclRoYW5FcXVhbFRvOiBtYnJTaWdJbmNyZWFzZSB9CgkvLyAgICAgICAgIH0pCgkvLyB2ZXJpZnkgcmVjZWl2ZXIKCWZyYW1lX2RpZyAtMSAvLyBjb3N0czogUGF5VHhuCglndHhucyBSZWNlaXZlcgoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyB2ZXJpZnkgYW1vdW50CglmcmFtZV9kaWcgLTEgLy8gY29zdHM6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMCAvLyBtYnJTaWdJbmNyZWFzZTogdWludDY0Cgk+PQoJYXNzZXJ0CgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czozOTAKCS8vIHNpZ25hdHVyZUJveDogVHJhbnNhY3Rpb25TaWduYXR1cmVzID0gewoJLy8gICAgICAgICAgICAgbm9uY2U6IHRyYW5zYWN0aW9uR3JvdXAsCgkvLyAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLnR4bi5zZW5kZXIKCS8vICAgICAgICAgfQoJZnJhbWVfZGlnIC0yIC8vIHRyYW5zYWN0aW9uR3JvdXA6IHVpbnQ2NAoJaXRvYgoJdHhuIFNlbmRlcgoJY29uY2F0CglmcmFtZV9idXJ5IDEgLy8gc2lnbmF0dXJlQm94OiBUcmFuc2FjdGlvblNpZ25hdHVyZXMKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjM5NQoJLy8gdGhpcy5fc2lnbmF0dXJlcyhzaWduYXR1cmVCb3gpLnZhbHVlID0gc2lnbmF0dXJlcwoJZnJhbWVfZGlnIDEgLy8gc2lnbmF0dXJlQm94OiBUcmFuc2FjdGlvblNpZ25hdHVyZXMKCWR1cAoJYm94X2RlbAoJcG9wCglmcmFtZV9kaWcgLTMgLy8gc2lnbmF0dXJlczogYnl0ZXM2NFtdCglkdXAKCWxlbgoJaW50IDY0CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cglib3hfcHV0CgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czozOTgKCS8vIHRoaXMuU2lnbmF0dXJlU2V0LmxvZyh7CgkvLyAgICAgICAgICAgICB0cmFuc2FjdGlvbkdyb3VwOiB0cmFuc2FjdGlvbkdyb3VwLAoJLy8gICAgICAgICAgICAgc2lnbmVyOiB0aGlzLnR4bi5zZW5kZXIKCS8vICAgICAgICAgfSkKCWJ5dGUgMHhlY2ZiY2IzMyAvLyBTaWduYXR1cmVTZXQodWludDY0LGFkZHJlc3MpCglmcmFtZV9kaWcgLTIgLy8gdHJhbnNhY3Rpb25Hcm91cDogdWludDY0CglpdG9iCgl0eG4gU2VuZGVyCgljb25jYXQKCWNvbmNhdAoJbG9nCglyZXRzdWIKCi8vIGFyYzU1X2NsZWFyU2lnbmF0dXJlcyh1aW50NjQsYWRkcmVzcyl2b2lkCmFiaV9yb3V0ZV9hcmM1NV9jbGVhclNpZ25hdHVyZXM6CgkvLyBhZGRyZXNzOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglkdXAKCWxlbgoJaW50IDMyCgk9PQoJYXNzZXJ0CgoJLy8gdHJhbnNhY3Rpb25Hcm91cDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBhcmM1NV9jbGVhclNpZ25hdHVyZXModWludDY0LGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBhcmM1NV9jbGVhclNpZ25hdHVyZXMKCWludCAxCglyZXR1cm4KCi8vIGFyYzU1X2NsZWFyU2lnbmF0dXJlcyh0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQsIGFkZHJlc3M6IEFkZHJlc3MpOiB2b2lkCi8vCi8vIENsZWFyIHNpZ25hdHVyZXMgZm9yIGFuIGFkZHJlc3MuIEJlIGF3YXJlIHRoaXMgb25seSByZW1vdmVzIGl0IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGxlZGdlciwgYW5kIGluZGV4ZXJzIHdpbGwgc3RpbGwga25vdyBhbmQgY291bGQgdXNlIHlvdXIgc2lnbmF0dXJlCi8vIEBwYXJhbSB0cmFuc2FjdGlvbkdyb3VwIFRyYW5zYWN0aW9uIEdyb3VwIG5vbmNlCi8vIEBwYXJhbSBhZGRyZXNzIEFkZHJlc3Mgd2hvc2Ugc2lnbmF0dXJlcyB0byBjbGVhcgphcmM1NV9jbGVhclNpZ25hdHVyZXM6Cglwcm90byAyIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAzCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czo0MTMKCS8vIHRoaXMub25seVNpZ25lcigpCgljYWxsc3ViIG9ubHlTaWduZXIKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjQxNQoJLy8gc2lnbmF0dXJlQm94OiBUcmFuc2FjdGlvblNpZ25hdHVyZXMgPSB7CgkvLyAgICAgICAgICAgICBub25jZTogdHJhbnNhY3Rpb25Hcm91cCwKCS8vICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MKCS8vICAgICAgICAgfQoJZnJhbWVfZGlnIC0xIC8vIHRyYW5zYWN0aW9uR3JvdXA6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIC0yIC8vIGFkZHJlc3M6IEFkZHJlc3MKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIHNpZ25hdHVyZUJveDogVHJhbnNhY3Rpb25TaWduYXR1cmVzCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czo0MjAKCS8vIHNpZ0xlbmd0aCA9IHRoaXMuX3NpZ25hdHVyZXMoc2lnbmF0dXJlQm94KS5zaXplCglmcmFtZV9kaWcgMCAvLyBzaWduYXR1cmVCb3g6IFRyYW5zYWN0aW9uU2lnbmF0dXJlcwoJYm94X2xlbgoJYXNzZXJ0CglmcmFtZV9idXJ5IDEgLy8gc2lnTGVuZ3RoOiB1aW50NjQKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjQyMQoJLy8gdGhpcy5fc2lnbmF0dXJlcyhzaWduYXR1cmVCb3gpLmRlbGV0ZQoJZnJhbWVfZGlnIDAgLy8gc2lnbmF0dXJlQm94OiBUcmFuc2FjdGlvblNpZ25hdHVyZXMKCWJveF9kZWwKCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjQyNgoJLy8gbWJyU2lnRGVjcmVhc2UgPSAoMjUwMCkgKyAoNDAwICogKDQwICsgc2lnTGVuZ3RoKSkKCWludCAyNTAwCglpbnQgNDAwCglpbnQgNDAKCWZyYW1lX2RpZyAxIC8vIHNpZ0xlbmd0aDogdWludDY0CgkrCgkqCgkrCglmcmFtZV9idXJ5IDIgLy8gbWJyU2lnRGVjcmVhc2U6IHVpbnQ2NAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6NDI4CgkvLyBzZW5kUGF5bWVudCh7CgkvLyAgICAgICAgICAgICByZWNlaXZlcjogYWRkcmVzcywKCS8vICAgICAgICAgICAgIGFtb3VudDogbWJyU2lnRGVjcmVhc2UKCS8vICAgICAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBzcmMvYXJjcy9hcmM1NS5hbGdvLnRzOjQyOQoJLy8gcmVjZWl2ZXI6IGFkZHJlc3MKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gc3JjL2FyY3MvYXJjNTUuYWxnby50czo0MzAKCS8vIGFtb3VudDogbWJyU2lnRGVjcmVhc2UKCWZyYW1lX2RpZyAyIC8vIG1iclNpZ0RlY3JlYXNlOiB1aW50NjQKCWl0eG5fZmllbGQgQW1vdW50CgoJLy8gRmVlIGZpZWxkIG5vdCBzZXQsIGRlZmF1bHRpbmcgdG8gMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoKCS8vIHNyYy9hcmNzL2FyYzU1LmFsZ28udHM6NDM0CgkvLyB0aGlzLlNpZ25hdHVyZVNldC5sb2coewoJLy8gICAgICAgICAgICAgdHJhbnNhY3Rpb25Hcm91cDogdHJhbnNhY3Rpb25Hcm91cCwKCS8vICAgICAgICAgICAgIHNpZ25lcjogYWRkcmVzcwoJLy8gICAgICAgICB9KQoJYnl0ZSAweGVjZmJjYjMzIC8vIFNpZ25hdHVyZVNldCh1aW50NjQsYWRkcmVzcykKCWZyYW1lX2RpZyAtMSAvLyB0cmFuc2FjdGlvbkdyb3VwOiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAtMiAvLyBhZGRyZXNzOiBBZGRyZXNzCgljb25jYXQKCWNvbmNhdAoJbG9nCglyZXRzdWIKCi8vIGRlcGxveSgpdWludDY0CmFiaV9yb3V0ZV9kZXBsb3k6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIGV4ZWN1dGUgZGVwbG95KCl1aW50NjQKCWNhbGxzdWIgZGVwbG95CglpdG9iCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZGVwbG95KCk6IEFwcGxpY2F0aW9uCi8vCi8vIERlcGxveSBhIG5ldyBPbi1DaGFpbiBNc2lnIEFwcC4KLy8gQHJldHVybnMgTXNpZyBBcHAgQXBwbGljYXRpb24gSUQKZGVwbG95OgoJcHJvdG8gMCAxCgoJLy8gc3JjL21zaWctYXBwLmFsZ28udHM6MTEKCS8vIHJldHVybiBnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbklEOwoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbklECglyZXRzdWIKCi8vIHVwZGF0ZSgpdm9pZAphYmlfcm91dGVfdXBkYXRlOgoJLy8gZXhlY3V0ZSB1cGRhdGUoKXZvaWQKCWNhbGxzdWIgdXBkYXRlCglpbnQgMQoJcmV0dXJuCgovLyB1cGRhdGUoKTogdm9pZAovLwovLyBVcGRhdGUgdGhlIGFwcGxpY2F0aW9uCnVwZGF0ZToKCXByb3RvIDAgMAoKCS8vIHNyYy9tc2lnLWFwcC5hbGdvLnRzOjE5CgkvLyB0aGlzLm9ubHlDcmVhdG9yKCkKCWNhbGxzdWIgb25seUNyZWF0b3IKCXJldHN1YgoKLy8gZGVzdHJveSgpdm9pZAphYmlfcm91dGVfZGVzdHJveToKCS8vIGV4ZWN1dGUgZGVzdHJveSgpdm9pZAoJY2FsbHN1YiBkZXN0cm95CglpbnQgMQoJcmV0dXJuCgovLyBkZXN0cm95KCk6IHZvaWQKLy8KLy8gRGVzdHJveSB0aGUgYXBwbGljYXRpb24gYW5kIHJldHVybiBmdW5kcyB0byBjcmVhdG9yIGFkZHJlc3MuIEFsbCB0cmFuc2FjdGlvbnMgbXVzdCBiZSByZW1vdmVkIGJlZm9yZSBjYWxsaW5nIGRlc3Ryb3kKZGVzdHJveToKCXByb3RvIDAgMAoKCS8vIHNyYy9tc2lnLWFwcC5hbGdvLnRzOjI3CgkvLyB0aGlzLm9ubHlDcmVhdG9yKCkKCWNhbGxzdWIgb25seUNyZWF0b3IKCgkvLyBzcmMvbXNpZy1hcHAuYWxnby50czoyOQoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgICAgICAgYW1vdW50OiAwLAoJLy8gICAgICAgICAgICAgcmVjZWl2ZXI6IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MsCgkvLyAgICAgICAgICAgICBjbG9zZVJlbWFpbmRlclRvOiBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzLAoJLy8gICAgICAgICAgICAgZmVlOiAwLAoJLy8gICAgICAgICB9KQoJaXR4bl9iZWdpbgoJaW50IHBheQoJaXR4bl9maWVsZCBUeXBlRW51bQoKCS8vIHNyYy9tc2lnLWFwcC5hbGdvLnRzOjMwCgkvLyBhbW91bnQ6IDAKCWludCAwCglpdHhuX2ZpZWxkIEFtb3VudAoKCS8vIHNyYy9tc2lnLWFwcC5hbGdvLnRzOjMxCgkvLyByZWNlaXZlcjogZ2xvYmFscy5jcmVhdG9yQWRkcmVzcwoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCglpdHhuX2ZpZWxkIFJlY2VpdmVyCgoJLy8gc3JjL21zaWctYXBwLmFsZ28udHM6MzIKCS8vIGNsb3NlUmVtYWluZGVyVG86IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJaXR4bl9maWVsZCBDbG9zZVJlbWFpbmRlclRvCgoJLy8gc3JjL21zaWctYXBwLmFsZ28udHM6MzMKCS8vIGZlZTogMAoJaW50IDAKCWl0eG5fZmllbGQgRmVlCgoJLy8gU3VibWl0IGlubmVyIHRyYW5zYWN0aW9uCglpdHhuX3N1Ym1pdAoJcmV0c3ViCgpjcmVhdGVfTm9PcDoKCW1ldGhvZCAiZGVwbG95KCl1aW50NjQiCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAwCgltYXRjaCBhYmlfcm91dGVfZGVwbG95CgllcnIKCmNhbGxfTm9PcDoKCW1ldGhvZCAiYXJjNTVfdGhyZXNob2xkKCl1aW50NjQiCgltZXRob2QgImFyYzU1X25leHRUcmFuc2FjdGlvbkdyb3VwKCl1aW50NjQiCgltZXRob2QgImFyYzU1X3RyYW5zYWN0aW9uKHVpbnQ2NCx1aW50OClieXRlW10iCgltZXRob2QgImFyYzU1X3NpZ25hdHVyZXModWludDY0LGFkZHJlc3MpYnl0ZVs2NF1bXSIKCW1ldGhvZCAiYXJjNTVfc2lnbmVyQnlJbmRleCh1aW50NjQpYWRkcmVzcyIKCW1ldGhvZCAiYXJjNTVfaXNTaWduZXIoYWRkcmVzcylib29sIgoJbWV0aG9kICJhcmM1NV9tYnJTaWdJbmNyZWFzZSh1aW50NjQpdWludDY0IgoJbWV0aG9kICJhcmM1NV9tYnJUeG5JbmNyZWFzZSh1aW50NjQpdWludDY0IgoJbWV0aG9kICJhcmM1NV9zZXR1cCh1aW50OCxhZGRyZXNzW10pdm9pZCIKCW1ldGhvZCAiYXJjNTVfbmV3VHJhbnNhY3Rpb25Hcm91cCgpdWludDY0IgoJbWV0aG9kICJhcmM1NV9hZGRUcmFuc2FjdGlvbihwYXksdWludDY0LHVpbnQ4LGJ5dGVbXSl2b2lkIgoJbWV0aG9kICJhcmM1NV9hZGRUcmFuc2FjdGlvbkNvbnRpbnVlZChieXRlW10pdm9pZCIKCW1ldGhvZCAiYXJjNTVfcmVtb3ZlVHJhbnNhY3Rpb24odWludDY0LHVpbnQ4KXZvaWQiCgltZXRob2QgImFyYzU1X3NldFNpZ25hdHVyZXMocGF5LHVpbnQ2NCxieXRlWzY0XVtdKXZvaWQiCgltZXRob2QgImFyYzU1X2NsZWFyU2lnbmF0dXJlcyh1aW50NjQsYWRkcmVzcyl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggYWJpX3JvdXRlX2FyYzU1X3RocmVzaG9sZCBhYmlfcm91dGVfYXJjNTVfbmV4dFRyYW5zYWN0aW9uR3JvdXAgYWJpX3JvdXRlX2FyYzU1X3RyYW5zYWN0aW9uIGFiaV9yb3V0ZV9hcmM1NV9zaWduYXR1cmVzIGFiaV9yb3V0ZV9hcmM1NV9zaWduZXJCeUluZGV4IGFiaV9yb3V0ZV9hcmM1NV9pc1NpZ25lciBhYmlfcm91dGVfYXJjNTVfbWJyU2lnSW5jcmVhc2UgYWJpX3JvdXRlX2FyYzU1X21iclR4bkluY3JlYXNlIGFiaV9yb3V0ZV9hcmM1NV9zZXR1cCBhYmlfcm91dGVfYXJjNTVfbmV3VHJhbnNhY3Rpb25Hcm91cCBhYmlfcm91dGVfYXJjNTVfYWRkVHJhbnNhY3Rpb24gYWJpX3JvdXRlX2FyYzU1X2FkZFRyYW5zYWN0aW9uQ29udGludWVkIGFiaV9yb3V0ZV9hcmM1NV9yZW1vdmVUcmFuc2FjdGlvbiBhYmlfcm91dGVfYXJjNTVfc2V0U2lnbmF0dXJlcyBhYmlfcm91dGVfYXJjNTVfY2xlYXJTaWduYXR1cmVzCgllcnIKCmNhbGxfVXBkYXRlQXBwbGljYXRpb246CgltZXRob2QgInVwZGF0ZSgpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoIGFiaV9yb3V0ZV91cGRhdGUKCWVycgoKY2FsbF9EZWxldGVBcHBsaWNhdGlvbjoKCW1ldGhvZCAiZGVzdHJveSgpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoIGFiaV9yb3V0ZV9kZXN0cm95CgllcnI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "MsigApp",
    "desc": "",
    "methods": [
      {
        "name": "arc55_threshold",
        "desc": "Retrieve the signature threshold required for the multisignature to be submitted",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64",
          "desc": "Multisignature threshold"
        }
      },
      {
        "name": "arc55_nextTransactionGroup",
        "readonly": true,
        "args": [],
        "returns": {
          "type": "uint64",
          "desc": "Next expected Transaction Group nonce"
        }
      },
      {
        "name": "arc55_transaction",
        "desc": "Retrieve a transaction from a given transaction group",
        "readonly": true,
        "args": [
          {
            "name": "transactionGroup",
            "type": "uint64",
            "desc": "Transaction Group nonce"
          },
          {
            "name": "transactionIndex",
            "type": "uint8",
            "desc": "Index of transaction within group"
          }
        ],
        "returns": {
          "type": "byte[]",
          "desc": "A single transaction at the specified index for the transaction group nonce"
        }
      },
      {
        "name": "arc55_signatures",
        "desc": "Retrieve a list of signatures for a given transaction group nonce and address",
        "readonly": true,
        "args": [
          {
            "name": "transactionGroup",
            "type": "uint64",
            "desc": "Transaction Group nonce"
          },
          {
            "name": "signer",
            "type": "address",
            "desc": "Address you want to retrieve signatures for"
          }
        ],
        "returns": {
          "type": "byte[64][]",
          "desc": "Array of signatures"
        }
      },
      {
        "name": "arc55_signerByIndex",
        "desc": "Find out which address is at this index of the multisignature",
        "readonly": true,
        "args": [
          {
            "name": "index",
            "type": "uint64",
            "desc": "Address at this index of the multisignature"
          }
        ],
        "returns": {
          "type": "address",
          "desc": "Address at index"
        }
      },
      {
        "name": "arc55_isSigner",
        "desc": "Check if an address is a member of the multisignature",
        "readonly": true,
        "args": [
          {
            "name": "address",
            "type": "address",
            "desc": "Address to check is a signer"
          }
        ],
        "returns": {
          "type": "bool",
          "desc": "True if address is a signer"
        }
      },
      {
        "name": "arc55_mbrSigIncrease",
        "desc": "Calculate the minimum balance requirement for storing a signature",
        "readonly": true,
        "args": [
          {
            "name": "signaturesSize",
            "type": "uint64",
            "desc": "Size (in bytes) of the signatures to store"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "Minimum balance requirement increase"
        }
      },
      {
        "name": "arc55_mbrTxnIncrease",
        "desc": "Calculate the minimum balance requirement for storing a transaction",
        "readonly": true,
        "args": [
          {
            "name": "transactionSize",
            "type": "uint64",
            "desc": "Size (in bytes) of the transaction to store"
          }
        ],
        "returns": {
          "type": "uint64",
          "desc": "Minimum balance requirement increase"
        }
      },
      {
        "name": "arc55_setup",
        "desc": "Setup On-Chain Msig App. This can only be called whilst no transaction groups have been created.",
        "args": [
          {
            "name": "threshold",
            "type": "uint8",
            "desc": "Initial multisig threshold, must be greater than 0"
          },
          {
            "name": "addresses",
            "type": "address[]",
            "desc": "Array of addresses that make up the multisig"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "arc55_newTransactionGroup",
        "desc": "Generate a new transaction group nonce for holding pending transactions",
        "args": [],
        "returns": {
          "type": "uint64",
          "desc": "transactionGroup Transaction Group nonce"
        }
      },
      {
        "name": "arc55_addTransaction",
        "desc": "Add a transaction to an existing group. Only one transaction should be included per call",
        "args": [
          {
            "name": "costs",
            "type": "pay",
            "desc": "Minimum Balance Requirement for associated box storage costs: (2500) + (400 * (9 + transaction.length))"
          },
          {
            "name": "transactionGroup",
            "type": "uint64",
            "desc": "Transaction Group nonce"
          },
          {
            "name": "index",
            "type": "uint8",
            "desc": "Transaction position within atomic group to add"
          },
          {
            "name": "transaction",
            "type": "byte[]",
            "desc": "Transaction to add"
          }
        ],
        "returns": {
          "type": "void"
        },
        "events": [
          {
            "name": "TransactionAdded",
            "args": [
              {
                "name": "transactionGroup",
                "type": "uint64"
              },
              {
                "name": "transactionIndex",
                "type": "uint8"
              }
            ],
            "desc": "Emitted when a new transaction is added to a transaction group"
          }
        ]
      },
      {
        "name": "arc55_addTransactionContinued",
        "args": [
          {
            "name": "transaction",
            "type": "byte[]"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "arc55_removeTransaction",
        "desc": "Remove transaction from the app. The MBR associated with the transaction will be returned to the transaction sender.",
        "args": [
          {
            "name": "transactionGroup",
            "type": "uint64",
            "desc": "Transaction Group nonce"
          },
          {
            "name": "index",
            "type": "uint8",
            "desc": "Transaction position within atomic group to remove"
          }
        ],
        "returns": {
          "type": "void"
        },
        "events": [
          {
            "name": "TransactionRemoved",
            "args": [
              {
                "name": "transactionGroup",
                "type": "uint64"
              },
              {
                "name": "transactionIndex",
                "type": "uint8"
              }
            ],
            "desc": "Emitted when a transaction has been removed from a transaction group"
          }
        ]
      },
      {
        "name": "arc55_setSignatures",
        "desc": "Set signatures for a particular transaction group. Signatures must be included as an array of byte-arrays",
        "args": [
          {
            "name": "costs",
            "type": "pay",
            "desc": "Minimum Balance Requirement for associated box storage costs: (2500) + (400 * (40 + signatures.length))"
          },
          {
            "name": "transactionGroup",
            "type": "uint64",
            "desc": "Transaction Group nonce"
          },
          {
            "name": "signatures",
            "type": "byte[64][]",
            "desc": "Array of signatures"
          }
        ],
        "returns": {
          "type": "void"
        },
        "events": [
          {
            "name": "SignatureSet",
            "args": [
              {
                "name": "transactionGroup",
                "type": "uint64"
              },
              {
                "name": "signer",
                "type": "address"
              }
            ],
            "desc": "Emitted when a new signature is added to a transaction group"
          }
        ]
      },
      {
        "name": "arc55_clearSignatures",
        "desc": "Clear signatures for an address. Be aware this only removes it from the current state of the ledger, and indexers will still know and could use your signature",
        "args": [
          {
            "name": "transactionGroup",
            "type": "uint64",
            "desc": "Transaction Group nonce"
          },
          {
            "name": "address",
            "type": "address",
            "desc": "Address whose signatures to clear"
          }
        ],
        "returns": {
          "type": "void"
        },
        "events": [
          {
            "name": "SignatureSet",
            "args": [
              {
                "name": "transactionGroup",
                "type": "uint64"
              },
              {
                "name": "signer",
                "type": "address"
              }
            ],
            "desc": "Emitted when a new signature is added to a transaction group"
          }
        ]
      },
      {
        "name": "deploy",
        "desc": "Deploy a new On-Chain Msig App.",
        "args": [],
        "returns": {
          "type": "uint64",
          "desc": "Msig App Application ID"
        }
      },
      {
        "name": "update",
        "desc": "Update the application",
        "args": [],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "destroy",
        "desc": "Destroy the application and return funds to creator address. All transactions must be removed before calling destroy",
        "args": [],
        "returns": {
          "type": "void"
        }
      }
    ],
    "events": [
      {
        "name": "TransactionAdded",
        "args": [
          {
            "name": "transactionGroup",
            "type": "uint64"
          },
          {
            "name": "transactionIndex",
            "type": "uint8"
          }
        ],
        "desc": "Emitted when a new transaction is added to a transaction group"
      },
      {
        "name": "TransactionRemoved",
        "args": [
          {
            "name": "transactionGroup",
            "type": "uint64"
          },
          {
            "name": "transactionIndex",
            "type": "uint8"
          }
        ],
        "desc": "Emitted when a transaction has been removed from a transaction group"
      },
      {
        "name": "SignatureSet",
        "args": [
          {
            "name": "transactionGroup",
            "type": "uint64"
          },
          {
            "name": "signer",
            "type": "address"
          }
        ],
        "desc": "Emitted when a new signature is added to a transaction group"
      },
      {
        "name": "SignatureCleared",
        "args": [
          {
            "name": "transactionGroup",
            "type": "uint64"
          },
          {
            "name": "signer",
            "type": "address"
          }
        ],
        "desc": "Emitted when a signature has been removed from a transaction group"
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt 
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

/**
 * Defines the types of available calls and state of the MsigApp smart contract.
 */
export type MsigApp = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'arc55_threshold()uint64' | 'arc55_threshold', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Multisignature threshold
       */
      returns: bigint
    }>
    & Record<'arc55_nextTransactionGroup()uint64' | 'arc55_nextTransactionGroup', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Next expected Transaction Group nonce
       */
      returns: bigint
    }>
    & Record<'arc55_transaction(uint64,uint8)byte[]' | 'arc55_transaction', {
      argsObj: {
        /**
         * Transaction Group nonce
         */
        transactionGroup: bigint | number
        /**
         * Index of transaction within group
         */
        transactionIndex: number
      }
      argsTuple: [transactionGroup: bigint | number, transactionIndex: number]
      /**
       * A single transaction at the specified index for the transaction group nonce
       */
      returns: Uint8Array
    }>
    & Record<'arc55_signatures(uint64,address)byte[64][]' | 'arc55_signatures', {
      argsObj: {
        /**
         * Transaction Group nonce
         */
        transactionGroup: bigint | number
        /**
         * Address you want to retrieve signatures for
         */
        signer: string
      }
      argsTuple: [transactionGroup: bigint | number, signer: string]
      /**
       * Array of signatures
       */
      returns: Uint8Array[]
    }>
    & Record<'arc55_signerByIndex(uint64)address' | 'arc55_signerByIndex', {
      argsObj: {
        /**
         * Address at this index of the multisignature
         */
        index: bigint | number
      }
      argsTuple: [index: bigint | number]
      /**
       * Address at index
       */
      returns: string
    }>
    & Record<'arc55_isSigner(address)bool' | 'arc55_isSigner', {
      argsObj: {
        /**
         * Address to check is a signer
         */
        address: string
      }
      argsTuple: [address: string]
      /**
       * True if address is a signer
       */
      returns: boolean
    }>
    & Record<'arc55_mbrSigIncrease(uint64)uint64' | 'arc55_mbrSigIncrease', {
      argsObj: {
        /**
         * Size (in bytes) of the signatures to store
         */
        signaturesSize: bigint | number
      }
      argsTuple: [signaturesSize: bigint | number]
      /**
       * Minimum balance requirement increase
       */
      returns: bigint
    }>
    & Record<'arc55_mbrTxnIncrease(uint64)uint64' | 'arc55_mbrTxnIncrease', {
      argsObj: {
        /**
         * Size (in bytes) of the transaction to store
         */
        transactionSize: bigint | number
      }
      argsTuple: [transactionSize: bigint | number]
      /**
       * Minimum balance requirement increase
       */
      returns: bigint
    }>
    & Record<'arc55_setup(uint8,address[])void' | 'arc55_setup', {
      argsObj: {
        /**
         * Initial multisig threshold, must be greater than 0
         */
        threshold: number
        /**
         * Array of addresses that make up the multisig
         */
        addresses: string[]
      }
      argsTuple: [threshold: number, addresses: string[]]
      returns: void
    }>
    & Record<'arc55_newTransactionGroup()uint64' | 'arc55_newTransactionGroup', {
      argsObj: {
      }
      argsTuple: []
      /**
       * transactionGroup Transaction Group nonce
       */
      returns: bigint
    }>
    & Record<'arc55_addTransaction(pay,uint64,uint8,byte[])void' | 'arc55_addTransaction', {
      argsObj: {
        /**
         * Minimum Balance Requirement for associated box storage costs: (2500) + (400 * (9 + transaction.length))
         */
        costs: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Transaction Group nonce
         */
        transactionGroup: bigint | number
        /**
         * Transaction position within atomic group to add
         */
        index: number
        /**
         * Transaction to add
         */
        transaction: Uint8Array
      }
      argsTuple: [costs: TransactionToSign | Transaction | Promise<SendTransactionResult>, transactionGroup: bigint | number, index: number, transaction: Uint8Array]
      returns: void
    }>
    & Record<'arc55_addTransactionContinued(byte[])void' | 'arc55_addTransactionContinued', {
      argsObj: {
        transaction: Uint8Array
      }
      argsTuple: [transaction: Uint8Array]
      returns: void
    }>
    & Record<'arc55_removeTransaction(uint64,uint8)void' | 'arc55_removeTransaction', {
      argsObj: {
        /**
         * Transaction Group nonce
         */
        transactionGroup: bigint | number
        /**
         * Transaction position within atomic group to remove
         */
        index: number
      }
      argsTuple: [transactionGroup: bigint | number, index: number]
      returns: void
    }>
    & Record<'arc55_setSignatures(pay,uint64,byte[64][])void' | 'arc55_setSignatures', {
      argsObj: {
        /**
         * Minimum Balance Requirement for associated box storage costs: (2500) + (400 * (40 + signatures.length))
         */
        costs: TransactionToSign | Transaction | Promise<SendTransactionResult>
        /**
         * Transaction Group nonce
         */
        transactionGroup: bigint | number
        /**
         * Array of signatures
         */
        signatures: Uint8Array[]
      }
      argsTuple: [costs: TransactionToSign | Transaction | Promise<SendTransactionResult>, transactionGroup: bigint | number, signatures: Uint8Array[]]
      returns: void
    }>
    & Record<'arc55_clearSignatures(uint64,address)void' | 'arc55_clearSignatures', {
      argsObj: {
        /**
         * Transaction Group nonce
         */
        transactionGroup: bigint | number
        /**
         * Address whose signatures to clear
         */
        address: string
      }
      argsTuple: [transactionGroup: bigint | number, address: string]
      returns: void
    }>
    & Record<'deploy()uint64' | 'deploy', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Msig App Application ID
       */
      returns: bigint
    }>
    & Record<'update()void' | 'update', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
    & Record<'destroy()void' | 'destroy', {
      argsObj: {
      }
      argsTuple: []
      returns: void
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      '_threshold'?: IntegerState
      '_nonce'?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type MsigAppSig = keyof MsigApp['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends MsigAppSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the MsigApp smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends MsigAppSig> = MsigApp['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the MsigApp smart contract to the method's return type
 */
export type MethodReturn<TSignature extends MsigAppSig> = MsigApp['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type MsigAppCreateCalls = (typeof MsigAppCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type MsigAppCreateCallParams =
  | (TypedCallParams<'deploy()uint64'> & (OnCompleteNoOp))
/**
 * A factory for available 'update' calls
 */
export type MsigAppUpdateCalls = (typeof MsigAppCallFactory)['update']
/**
 * Defines supported update methods for this smart contract
 */
export type MsigAppUpdateCallParams =
  | TypedCallParams<'update()void'>
/**
 * A factory for available 'delete' calls
 */
export type MsigAppDeleteCalls = (typeof MsigAppCallFactory)['delete']
/**
 * Defines supported delete methods for this smart contract
 */
export type MsigAppDeleteCallParams =
  | TypedCallParams<'destroy()void'>
/**
 * Defines arguments required for the deploy method.
 */
export type MsigAppDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: MsigAppCreateCalls) => MsigAppCreateCallParams
  /**
   * A delegate which takes a update call factory and returns the update call params for this smart contract
   */
  updateCall?: (callFactory: MsigAppUpdateCalls) => MsigAppUpdateCallParams
  /**
   * A delegate which takes a delete call factory and returns the delete call params for this smart contract
   */
  deleteCall?: (callFactory: MsigAppDeleteCalls) => MsigAppDeleteCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class MsigAppCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the MsigApp smart contract using the deploy()uint64 ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      deploy(args: MethodArgs<'deploy()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'deploy()uint64' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Gets available update call factories
   */
  static get update() {
    return {
      /**
       * Constructs an update call for the MsigApp smart contract using the update()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      update(args: MethodArgs<'update()void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {}) {
        return {
          method: 'update()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Gets available delete call factories
   */
  static get delete() {
    return {
      /**
       * Constructs a delete call for the MsigApp smart contract using the destroy()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      destroy(args: MethodArgs<'destroy()void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
        return {
          method: 'destroy()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the arc55_threshold()uint64 ABI method
   *
   * Retrieve the signature threshold required for the multisignature to be submitted
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55Threshold(args: MethodArgs<'arc55_threshold()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_threshold()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_nextTransactionGroup()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55NextTransactionGroup(args: MethodArgs<'arc55_nextTransactionGroup()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_nextTransactionGroup()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_transaction(uint64,uint8)byte[] ABI method
   *
   * Retrieve a transaction from a given transaction group
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55Transaction(args: MethodArgs<'arc55_transaction(uint64,uint8)byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_transaction(uint64,uint8)byte[]' as const,
      methodArgs: Array.isArray(args) ? args : [args.transactionGroup, args.transactionIndex],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_signatures(uint64,address)byte[64][] ABI method
   *
   * Retrieve a list of signatures for a given transaction group nonce and address
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55Signatures(args: MethodArgs<'arc55_signatures(uint64,address)byte[64][]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_signatures(uint64,address)byte[64][]' as const,
      methodArgs: Array.isArray(args) ? args : [args.transactionGroup, args.signer],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_signerByIndex(uint64)address ABI method
   *
   * Find out which address is at this index of the multisignature
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55SignerByIndex(args: MethodArgs<'arc55_signerByIndex(uint64)address'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_signerByIndex(uint64)address' as const,
      methodArgs: Array.isArray(args) ? args : [args.index],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_isSigner(address)bool ABI method
   *
   * Check if an address is a member of the multisignature
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55IsSigner(args: MethodArgs<'arc55_isSigner(address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_isSigner(address)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args.address],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_mbrSigIncrease(uint64)uint64 ABI method
   *
   * Calculate the minimum balance requirement for storing a signature
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55MbrSigIncrease(args: MethodArgs<'arc55_mbrSigIncrease(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_mbrSigIncrease(uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.signaturesSize],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_mbrTxnIncrease(uint64)uint64 ABI method
   *
   * Calculate the minimum balance requirement for storing a transaction
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55MbrTxnIncrease(args: MethodArgs<'arc55_mbrTxnIncrease(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_mbrTxnIncrease(uint64)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args.transactionSize],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_setup(uint8,address[])void ABI method
   *
   * Setup On-Chain Msig App. This can only be called whilst no transaction groups have been created.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55Setup(args: MethodArgs<'arc55_setup(uint8,address[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_setup(uint8,address[])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.threshold, args.addresses],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_newTransactionGroup()uint64 ABI method
   *
   * Generate a new transaction group nonce for holding pending transactions
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55NewTransactionGroup(args: MethodArgs<'arc55_newTransactionGroup()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_newTransactionGroup()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_addTransaction(pay,uint64,uint8,byte[])void ABI method
   *
   * Add a transaction to an existing group. Only one transaction should be included per call
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55AddTransaction(args: MethodArgs<'arc55_addTransaction(pay,uint64,uint8,byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_addTransaction(pay,uint64,uint8,byte[])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.costs, args.transactionGroup, args.index, args.transaction],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_addTransactionContinued(byte[])void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55AddTransactionContinued(args: MethodArgs<'arc55_addTransactionContinued(byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_addTransactionContinued(byte[])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.transaction],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_removeTransaction(uint64,uint8)void ABI method
   *
   * Remove transaction from the app. The MBR associated with the transaction will be returned to the transaction sender.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55RemoveTransaction(args: MethodArgs<'arc55_removeTransaction(uint64,uint8)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_removeTransaction(uint64,uint8)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.transactionGroup, args.index],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_setSignatures(pay,uint64,byte[64][])void ABI method
   *
   * Set signatures for a particular transaction group. Signatures must be included as an array of byte-arrays
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55SetSignatures(args: MethodArgs<'arc55_setSignatures(pay,uint64,byte[64][])void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_setSignatures(pay,uint64,byte[64][])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.costs, args.transactionGroup, args.signatures],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the arc55_clearSignatures(uint64,address)void ABI method
   *
   * Clear signatures for an address. Be aware this only removes it from the current state of the ledger, and indexers will still know and could use your signature
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static arc55ClearSignatures(args: MethodArgs<'arc55_clearSignatures(uint64,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'arc55_clearSignatures(uint64,address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.transactionGroup, args.address],
      ...params,
    }
  }
}

/**
 * A client to make calls to the MsigApp smart contract
 */
export class MsigAppClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `MsigAppClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof MsigApp['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the MsigApp smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: MsigAppDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(MsigAppCallFactory.create)
    const updateArgs = params.updateCall?.(MsigAppCallFactory.update)
    const deleteArgs = params.deleteCall?.(MsigAppCallFactory.delete)
    return this.appClient.deploy({
      ...params,
      updateArgs,
      deleteArgs,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the MsigApp smart contract using the deploy()uint64 ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result: Msig App Application ID
       */
      async deploy(args: MethodArgs<'deploy()uint64'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'deploy()uint64'>, AppCreateCallTransactionResult>(await $this.appClient.create(MsigAppCallFactory.create.deploy(args, params)))
      },
    }
  }

  /**
   * Gets available update methods
   */
  public get update() {
    const $this = this
    return {
      /**
       * Updates an existing instance of the MsigApp smart contract using the update()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The update result
       */
      async update(args: MethodArgs<'update()void'>, params: AppClientCallCoreParams & AppClientCompilationParams = {}) {
        return $this.mapReturnValue<MethodReturn<'update()void'>, AppUpdateCallTransactionResult>(await $this.appClient.update(MsigAppCallFactory.update.update(args, params)))
      },
    }
  }

  /**
   * Gets available delete methods
   */
  public get delete() {
    const $this = this
    return {
      /**
       * Deletes an existing instance of the MsigApp smart contract using the destroy()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The delete result
       */
      async destroy(args: MethodArgs<'destroy()void'>, params: AppClientCallCoreParams = {}) {
        return $this.mapReturnValue<MethodReturn<'destroy()void'>>(await $this.appClient.delete(MsigAppCallFactory.delete.destroy(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the MsigApp smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the arc55_threshold()uint64 ABI method.
   *
   * Retrieve the signature threshold required for the multisignature to be submitted
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Multisignature threshold
   */
  public arc55Threshold(args: MethodArgs<'arc55_threshold()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55Threshold(args, params))
  }

  /**
   * Calls the arc55_nextTransactionGroup()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Next expected Transaction Group nonce
   */
  public arc55NextTransactionGroup(args: MethodArgs<'arc55_nextTransactionGroup()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55NextTransactionGroup(args, params))
  }

  /**
   * Calls the arc55_transaction(uint64,uint8)byte[] ABI method.
   *
   * Retrieve a transaction from a given transaction group
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: A single transaction at the specified index for the transaction group nonce
   */
  public arc55Transaction(args: MethodArgs<'arc55_transaction(uint64,uint8)byte[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55Transaction(args, params))
  }

  /**
   * Calls the arc55_signatures(uint64,address)byte[64][] ABI method.
   *
   * Retrieve a list of signatures for a given transaction group nonce and address
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Array of signatures
   */
  public arc55Signatures(args: MethodArgs<'arc55_signatures(uint64,address)byte[64][]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55Signatures(args, params))
  }

  /**
   * Calls the arc55_signerByIndex(uint64)address ABI method.
   *
   * Find out which address is at this index of the multisignature
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address at index
   */
  public arc55SignerByIndex(args: MethodArgs<'arc55_signerByIndex(uint64)address'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55SignerByIndex(args, params))
  }

  /**
   * Calls the arc55_isSigner(address)bool ABI method.
   *
   * Check if an address is a member of the multisignature
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: True if address is a signer
   */
  public arc55IsSigner(args: MethodArgs<'arc55_isSigner(address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55IsSigner(args, params))
  }

  /**
   * Calls the arc55_mbrSigIncrease(uint64)uint64 ABI method.
   *
   * Calculate the minimum balance requirement for storing a signature
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Minimum balance requirement increase
   */
  public arc55MbrSigIncrease(args: MethodArgs<'arc55_mbrSigIncrease(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55MbrSigIncrease(args, params))
  }

  /**
   * Calls the arc55_mbrTxnIncrease(uint64)uint64 ABI method.
   *
   * Calculate the minimum balance requirement for storing a transaction
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Minimum balance requirement increase
   */
  public arc55MbrTxnIncrease(args: MethodArgs<'arc55_mbrTxnIncrease(uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55MbrTxnIncrease(args, params))
  }

  /**
   * Calls the arc55_setup(uint8,address[])void ABI method.
   *
   * Setup On-Chain Msig App. This can only be called whilst no transaction groups have been created.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public arc55Setup(args: MethodArgs<'arc55_setup(uint8,address[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55Setup(args, params))
  }

  /**
   * Calls the arc55_newTransactionGroup()uint64 ABI method.
   *
   * Generate a new transaction group nonce for holding pending transactions
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: transactionGroup Transaction Group nonce
   */
  public arc55NewTransactionGroup(args: MethodArgs<'arc55_newTransactionGroup()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55NewTransactionGroup(args, params))
  }

  /**
   * Calls the arc55_addTransaction(pay,uint64,uint8,byte[])void ABI method.
   *
   * Add a transaction to an existing group. Only one transaction should be included per call
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public arc55AddTransaction(args: MethodArgs<'arc55_addTransaction(pay,uint64,uint8,byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55AddTransaction(args, params))
  }

  /**
   * Calls the arc55_addTransactionContinued(byte[])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public arc55AddTransactionContinued(args: MethodArgs<'arc55_addTransactionContinued(byte[])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55AddTransactionContinued(args, params))
  }

  /**
   * Calls the arc55_removeTransaction(uint64,uint8)void ABI method.
   *
   * Remove transaction from the app. The MBR associated with the transaction will be returned to the transaction sender.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public arc55RemoveTransaction(args: MethodArgs<'arc55_removeTransaction(uint64,uint8)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55RemoveTransaction(args, params))
  }

  /**
   * Calls the arc55_setSignatures(pay,uint64,byte[64][])void ABI method.
   *
   * Set signatures for a particular transaction group. Signatures must be included as an array of byte-arrays
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public arc55SetSignatures(args: MethodArgs<'arc55_setSignatures(pay,uint64,byte[64][])void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55SetSignatures(args, params))
  }

  /**
   * Calls the arc55_clearSignatures(uint64,address)void ABI method.
   *
   * Clear signatures for an address. Be aware this only removes it from the current state of the ledger, and indexers will still know and could use your signature
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public arc55ClearSignatures(args: MethodArgs<'arc55_clearSignatures(uint64,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(MsigAppCallFactory.arc55ClearSignatures(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<MsigApp['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get _threshold() {
        return MsigAppClient.getIntegerState(state, '_threshold')
      },
      get _nonce() {
        return MsigAppClient.getIntegerState(state, '_nonce')
      },
    }
  }

  public compose(): MsigAppComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      arc55Threshold(args: MethodArgs<'arc55_threshold()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55Threshold(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55NextTransactionGroup(args: MethodArgs<'arc55_nextTransactionGroup()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55NextTransactionGroup(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55Transaction(args: MethodArgs<'arc55_transaction(uint64,uint8)byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55Transaction(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55Signatures(args: MethodArgs<'arc55_signatures(uint64,address)byte[64][]'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55Signatures(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55SignerByIndex(args: MethodArgs<'arc55_signerByIndex(uint64)address'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55SignerByIndex(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55IsSigner(args: MethodArgs<'arc55_isSigner(address)bool'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55IsSigner(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55MbrSigIncrease(args: MethodArgs<'arc55_mbrSigIncrease(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55MbrSigIncrease(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55MbrTxnIncrease(args: MethodArgs<'arc55_mbrTxnIncrease(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55MbrTxnIncrease(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55Setup(args: MethodArgs<'arc55_setup(uint8,address[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55Setup(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55NewTransactionGroup(args: MethodArgs<'arc55_newTransactionGroup()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55NewTransactionGroup(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55AddTransaction(args: MethodArgs<'arc55_addTransaction(pay,uint64,uint8,byte[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55AddTransaction(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55AddTransactionContinued(args: MethodArgs<'arc55_addTransactionContinued(byte[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55AddTransactionContinued(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55RemoveTransaction(args: MethodArgs<'arc55_removeTransaction(uint64,uint8)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55RemoveTransaction(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55SetSignatures(args: MethodArgs<'arc55_setSignatures(pay,uint64,byte[64][])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55SetSignatures(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      arc55ClearSignatures(args: MethodArgs<'arc55_clearSignatures(uint64,address)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.arc55ClearSignatures(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      get update() {
        const $this = this
        return {
          update(args: MethodArgs<'update()void'>, params?: AppClientCallCoreParams & AppClientCompilationParams) {
            promiseChain = promiseChain.then(() => client.update.update(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
            resultMappers.push(undefined)
            return $this
          },
        }
      },
      get delete() {
        const $this = this
        return {
          destroy(args: MethodArgs<'destroy()void'>, params?: AppClientCallCoreParams) {
            promiseChain = promiseChain.then(() => client.delete.destroy(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
            resultMappers.push(undefined)
            return $this
          },
        }
      },
      clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate() {
        await promiseChain
        const result = await atc.simulate(client.algod)
        return result
      },
      async execute() {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams: {} }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as MsigAppComposer
  }
}
export type MsigAppComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the arc55_threshold()uint64 ABI method.
   *
   * Retrieve the signature threshold required for the multisignature to be submitted
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55Threshold(args: MethodArgs<'arc55_threshold()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_threshold()uint64'>]>

  /**
   * Calls the arc55_nextTransactionGroup()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55NextTransactionGroup(args: MethodArgs<'arc55_nextTransactionGroup()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_nextTransactionGroup()uint64'>]>

  /**
   * Calls the arc55_transaction(uint64,uint8)byte[] ABI method.
   *
   * Retrieve a transaction from a given transaction group
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55Transaction(args: MethodArgs<'arc55_transaction(uint64,uint8)byte[]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_transaction(uint64,uint8)byte[]'>]>

  /**
   * Calls the arc55_signatures(uint64,address)byte[64][] ABI method.
   *
   * Retrieve a list of signatures for a given transaction group nonce and address
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55Signatures(args: MethodArgs<'arc55_signatures(uint64,address)byte[64][]'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_signatures(uint64,address)byte[64][]'>]>

  /**
   * Calls the arc55_signerByIndex(uint64)address ABI method.
   *
   * Find out which address is at this index of the multisignature
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55SignerByIndex(args: MethodArgs<'arc55_signerByIndex(uint64)address'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_signerByIndex(uint64)address'>]>

  /**
   * Calls the arc55_isSigner(address)bool ABI method.
   *
   * Check if an address is a member of the multisignature
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55IsSigner(args: MethodArgs<'arc55_isSigner(address)bool'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_isSigner(address)bool'>]>

  /**
   * Calls the arc55_mbrSigIncrease(uint64)uint64 ABI method.
   *
   * Calculate the minimum balance requirement for storing a signature
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55MbrSigIncrease(args: MethodArgs<'arc55_mbrSigIncrease(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_mbrSigIncrease(uint64)uint64'>]>

  /**
   * Calls the arc55_mbrTxnIncrease(uint64)uint64 ABI method.
   *
   * Calculate the minimum balance requirement for storing a transaction
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55MbrTxnIncrease(args: MethodArgs<'arc55_mbrTxnIncrease(uint64)uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_mbrTxnIncrease(uint64)uint64'>]>

  /**
   * Calls the arc55_setup(uint8,address[])void ABI method.
   *
   * Setup On-Chain Msig App. This can only be called whilst no transaction groups have been created.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55Setup(args: MethodArgs<'arc55_setup(uint8,address[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_setup(uint8,address[])void'>]>

  /**
   * Calls the arc55_newTransactionGroup()uint64 ABI method.
   *
   * Generate a new transaction group nonce for holding pending transactions
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55NewTransactionGroup(args: MethodArgs<'arc55_newTransactionGroup()uint64'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_newTransactionGroup()uint64'>]>

  /**
   * Calls the arc55_addTransaction(pay,uint64,uint8,byte[])void ABI method.
   *
   * Add a transaction to an existing group. Only one transaction should be included per call
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55AddTransaction(args: MethodArgs<'arc55_addTransaction(pay,uint64,uint8,byte[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_addTransaction(pay,uint64,uint8,byte[])void'>]>

  /**
   * Calls the arc55_addTransactionContinued(byte[])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55AddTransactionContinued(args: MethodArgs<'arc55_addTransactionContinued(byte[])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_addTransactionContinued(byte[])void'>]>

  /**
   * Calls the arc55_removeTransaction(uint64,uint8)void ABI method.
   *
   * Remove transaction from the app. The MBR associated with the transaction will be returned to the transaction sender.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55RemoveTransaction(args: MethodArgs<'arc55_removeTransaction(uint64,uint8)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_removeTransaction(uint64,uint8)void'>]>

  /**
   * Calls the arc55_setSignatures(pay,uint64,byte[64][])void ABI method.
   *
   * Set signatures for a particular transaction group. Signatures must be included as an array of byte-arrays
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55SetSignatures(args: MethodArgs<'arc55_setSignatures(pay,uint64,byte[64][])void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_setSignatures(pay,uint64,byte[64][])void'>]>

  /**
   * Calls the arc55_clearSignatures(uint64,address)void ABI method.
   *
   * Clear signatures for an address. Be aware this only removes it from the current state of the ledger, and indexers will still know and could use your signature
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  arc55ClearSignatures(args: MethodArgs<'arc55_clearSignatures(uint64,address)void'>, params?: AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, MethodReturn<'arc55_clearSignatures(uint64,address)void'>]>

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the MsigApp smart contract using the update()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    update(args: MethodArgs<'update()void'>, params?: AppClientCallCoreParams & AppClientCompilationParams): MsigAppComposer<[...TReturns, MethodReturn<'update()void'>]>
  }

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the MsigApp smart contract using the destroy()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    destroy(args: MethodArgs<'destroy()void'>, params?: AppClientCallCoreParams): MsigAppComposer<[...TReturns, MethodReturn<'destroy()void'>]>
  }

  /**
   * Makes a clear_state call to an existing instance of the MsigApp smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs): MsigAppComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): MsigAppComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<MsigAppComposerSimulateResult>
  /**
   * Executes the transaction group and returns the results
   */
  execute(): Promise<MsigAppComposerResults<TReturns>>
}
export type MsigAppComposerSimulateResult = {
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type MsigAppComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
